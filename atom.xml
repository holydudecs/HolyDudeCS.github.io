<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中国留学生CS作业代写</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://holydudecs.github.io/"/>
  <updated>2018-10-09T12:48:16.426Z</updated>
  <id>http://holydudecs.github.io/</id>
  
  <author>
    <name>Nameless Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS个人代写</title>
    <link href="http://holydudecs.github.io/2045/01/01/Task000000/"/>
    <id>http://holydudecs.github.io/2045/01/01/Task000000/</id>
    <published>2045-01-01T03:05:57.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍:"></a>个人介绍:</h1><p>本人是国内一名程序员</p><ul><li>毕业于<strong>国内CS专业第一高校</strong></li><li>先后在<strong>Baidu,阿里巴巴任职</strong></li><li>熟练掌握各种语言<strong>C/C++,java,python,matlab,Web</strong></li><li>代写范围从<strong>底层汇编到数据算法结构,人工智能,图像游戏,数据库,Android,IOS,Web</strong></li><li>辅导中国留学生CS作业,多年经验,熟知各科得分点</li><li>由于时间有限,本人不做代考与论文写作</li></ul><h1 id="cs作业代写"><a href="#cs作业代写" class="headerlink" title="cs作业代写:"></a>cs作业代写:</h1><h1 id="cs作业代写价格"><a href="#cs作业代写价格" class="headerlink" title="cs作业代写价格:"></a>cs作业代写价格:</h1><table><thead><tr><th>作业种类</th><th>大一</th><th>大二</th><th>大三</th><th>大四</th><th>硕博</th></tr></thead><tbody><tr><td>Lab</td><td>$30-$100</td><td>$75-$150</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Homework</td><td>$40-$150</td><td>$60-$200</td><td>$100-$220</td><td>$200-$280</td><td>$150-$400</td></tr><tr><td>Assignment</td><td>$50-$150</td><td>$80-$200</td><td>$120-$240</td><td>$160-$280</td><td>$150-$400</td></tr><tr><td>Project</td><td>$100-$150</td><td>$140-$200</td><td>$180-$220</td><td>$200-$280</td><td>$150-$400</td></tr><tr><td>Final</td><td>$100-$200</td><td>$140-$200</td><td>$180-$240</td><td>$220-$280</td><td>$150-$400</td></tr></tbody></table><p>请直接给我留言,睡醒之后会马上回复您.请发送给我您的要求,due,相关文件<br>请加微信联系: <img src="images/wechat.jpeg" alt="WeChat"></p><h1 id="作业反馈"><a href="#作业反馈" class="headerlink" title="作业反馈"></a>作业反馈</h1><a id="more"></a><p><img src="images/pic0.jpeg" alt="WeChat"><br><img src="images/pic1.jpeg" alt="WeChat"><br><img src="images/pic2.jpeg" alt="WeChat"><br><img src="images/pic3.jpeg" alt="WeChat"><br><img src="images/pic4.jpeg" alt="WeChat"><br><img src="images/pic5.jpeg" alt="WeChat"><br><img src="images/pic6.jpeg" alt="WeChat"><br><img src="images/pic7.jpeg" alt="WeChat"><br><img src="images/pic8.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;个人介绍&quot;&gt;&lt;a href=&quot;#个人介绍&quot; class=&quot;headerlink&quot; title=&quot;个人介绍:&quot;&gt;&lt;/a&gt;个人介绍:&lt;/h1&gt;&lt;p&gt;本人是国内一名程序员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;毕业于&lt;strong&gt;国内CS专业第一高校&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;先后在&lt;strong&gt;Baidu,阿里巴巴任职&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;熟练掌握各种语言&lt;strong&gt;C/C++,java,python,matlab,Web&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;代写范围从&lt;strong&gt;底层汇编到数据算法结构,人工智能,图像游戏,数据库,Android,IOS,Web&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;辅导中国留学生CS作业,多年经验,熟知各科得分点&lt;/li&gt;
&lt;li&gt;由于时间有限,本人不做代考与论文写作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;cs作业代写&quot;&gt;&lt;a href=&quot;#cs作业代写&quot; class=&quot;headerlink&quot; title=&quot;cs作业代写:&quot;&gt;&lt;/a&gt;cs作业代写:&lt;/h1&gt;&lt;h1 id=&quot;cs作业代写价格&quot;&gt;&lt;a href=&quot;#cs作业代写价格&quot; class=&quot;headerlink&quot; title=&quot;cs作业代写价格:&quot;&gt;&lt;/a&gt;cs作业代写价格:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作业种类&lt;/th&gt;
&lt;th&gt;大一&lt;/th&gt;
&lt;th&gt;大二&lt;/th&gt;
&lt;th&gt;大三&lt;/th&gt;
&lt;th&gt;大四&lt;/th&gt;
&lt;th&gt;硕博&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Lab&lt;/td&gt;
&lt;td&gt;$30-$100&lt;/td&gt;
&lt;td&gt;$75-$150&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Homework&lt;/td&gt;
&lt;td&gt;$40-$150&lt;/td&gt;
&lt;td&gt;$60-$200&lt;/td&gt;
&lt;td&gt;$100-$220&lt;/td&gt;
&lt;td&gt;$200-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assignment&lt;/td&gt;
&lt;td&gt;$50-$150&lt;/td&gt;
&lt;td&gt;$80-$200&lt;/td&gt;
&lt;td&gt;$120-$240&lt;/td&gt;
&lt;td&gt;$160-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Project&lt;/td&gt;
&lt;td&gt;$100-$150&lt;/td&gt;
&lt;td&gt;$140-$200&lt;/td&gt;
&lt;td&gt;$180-$220&lt;/td&gt;
&lt;td&gt;$200-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Final&lt;/td&gt;
&lt;td&gt;$100-$200&lt;/td&gt;
&lt;td&gt;$140-$200&lt;/td&gt;
&lt;td&gt;$180-$240&lt;/td&gt;
&lt;td&gt;$220-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请直接给我留言,睡醒之后会马上回复您.请发送给我您的要求,due,相关文件&lt;br&gt;请加微信联系: &lt;img src=&quot;images/wechat.jpeg&quot; alt=&quot;WeChat&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;作业反馈&quot;&gt;&lt;a href=&quot;#作业反馈&quot; class=&quot;headerlink&quot; title=&quot;作业反馈&quot;&gt;&lt;/a&gt;作业反馈&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Assignment</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000017/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000017/</id>
    <published>2018-11-04T09:25:14.000Z</published>
    <updated>2018-11-04T09:25:14.293Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写&lt;/p&gt;
&lt;p&gt;留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs
      
    
    </summary>
    
    
      <category term="c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写" scheme="http://holydudecs.github.io/tags/c-c-%E4%BB%A3%E5%86%99-java%E4%BB%A3%E5%86%99-python%E4%BB%A3%E5%86%99-matlab%E4%BB%A3%E5%86%99-%E4%BD%9C%E4%B8%9A%E4%BB%A3%E5%86%99-%E7%95%99%E5%AD%A6%E7%94%9F%E4%BD%9C%E4%B8%9A%E4%BB%A3%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>Project</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000016/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000016/</id>
    <published>2018-11-04T09:22:47.000Z</published>
    <updated>2018-11-04T09:23:51.224Z</updated>
    
    <content type="html"><![CDATA[<p>1 Introduction and purpose In review: a priority queue is a queue that stores elements that each have an associated priority. In this project the elements themselves will just be strings, and their priorities will be nonnegative integers. Regardless of the order that the elements were added to a priority queue, when an element is removed it is always the element being st</p><a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>1 Project #6 1 Introduction and purpose In review: a priority queue is a queue that stores elements that each have an associated priority. In this project the elements themselves will just be strings, and their priorities will be nonnegative integers. Regardless of the order that the elements were added to a priority queue, when an element is removed it is always the element being stored that has the highest priority that is removed and returned. Your functions must use only dynamically–allocated memory to store priority queues. The purpose of the project is to get experience using memory allocation and creating linked data structures in C. Consequently this project is more difficult than the recent two projects, because there are many possible bugs when using dynamically–allocated data structures in C, so start right away. Note that to encourage you to test your code yourself, secret tests are the largest component of your score for this project. 2 Data structure requirements You will create your own data structure for storing the components of a priority queue. We are giving you a header file pq.h that contains the prototypes of the required functions, assuming an undefined type Priorityqueue. It #includes a header file pq-datastructure.h that is not provided. You must create this file (with its name spelled exactly as shown), containing a definition of the type Priorityqueue. (Note that there is a second header file included in the tarfile that has a prototype for a utility function that you must also write, described below.) Your priority queue data structure must obey the following: • Your data structure must use only dynamically–allocated memory to store priority queues. Otherwise, you will not receive credit for the project (even if your code passes every test). One example of a dynamically–allocated data structure is a linked list of structs, where each struct is dynamically allocated (obtained via malloc() or calloc()). Another is a binary tree of structs, where each struct is dynamically allocated. • Your data structure for storing priority queues must use at least one linked list or one binary tree in storing priority queues. You can use more than one of these. You can use other dynamically–al- 2 located data structures, such as dynamically–allocated arrays (obtained via malloc() or calloc()), as long as you use at least one linked list or binary tree in your priority queue data structure. If your data structure does not use at least one linked list or binary tree you will not receive credit for the project (even if your code passes every test). • Your data structure for storing priority queues cannot use any fixed–size arrays anywhere. If any square braces () are seen anywhere in your pq-datastructure.h header file you will not receive credit for the project (even if your code passes every test). If you have any doubts about whether you are violating these requirements you can always discuss the design that you have come up with TAs during their office hours before starting to code. There are no requirements for your own tests– we won’t even be looking at them– so these restrictions do not apply to them, only to your priority queue implementation. You will not be graded directly on execution efficiency, but if your priority queue representation is highly inefficient (for example, extremely slow for large priority queues) you might fail some tests. 3 Functions to be written Note that you have to write two source files for this project. All of the functions will be in a file pq.c except the last one described below, which will be in a file check-string-arrays.c. The functions to be written do not print any output; they either modify their Priorityqueue parameter, or return a value, or both. Some functions have a Priorityqueue as a parameter. The others (the ones that can modify a priority queue) have a pointer to a Priorityqueue (i.e., a Priorityqueue ) as a parameter. Note the following: • If a pointer or array passed into a parameter of any function is NULL, the function should have no effect. The functions that have a pointer or array parameter and have an integer return value should just return 0 without changing anything if their pointer parameter is NULL. The one function that has a pointer as a parameter and returns a pointer (dequeue()) should just return NULL without changing anything if its pointer parameter is NULL. • It should be possible for a program that calls your functions to create multiple priority queues, and they should not conflict. In other words, initializing or modifying one of them should not affect any others. Write one function at a time (entirely or even partially), then test it (as soon as that is possible) thoroughly before going on! Write and test helper functions (for example, utility functions to ma- 3 nipulate your data structures) before writing code that uses them, and test them separately first as well. 3.1 Memory management For simplicity, the following apply: • A robust C program should always check that all memory allocations succeed, and take appropriate action if not. (The appropriate action might just be gracefully exiting the program, but it at least should not be just crashing). However, for simplicity in this project you may assume that all memory allocations always succeed, so you are encouraged but not required to check the return values of calls to the memory allocation functions. • A robust C program should always free all dynamically allocated memory when it’s no longer needed, to prevent memory leaks. However, for simplicity in this project your functions do not need to free any memory. Although some of the functions remove some or all of a priority queue’s components, it is sufficient if you accomplish this by removing components of your data structure without explicitly freeing the memory that they use (like to what you did in Java programs, except here there is no garbage collector that will free the memory eventually). • Since you don’t have to free memory your functions may have memory leaks, which you don’t have to worry too much about in this project. (Of course if you leak the entire heap memory and ask for more, the operating system will terminate your program, but given the sizes of inputs your functions will be run on, that should not occur.) 3.2 void init(Priorityqueue const pq) This function should initialize its Priorityqueue parameter (meaning the Priorityqueue variable that its pointer parameter points to), causing it to be an empty priority queue containing no elements. Exactly what the function has to do depends entirely on how you decide to represent priority queues. Note that the caller created the variable that pq points to, and is just passing its address into this function. This function is like initstudent() in Project #4 or copystudent() in Project #5. Both of these functions were passed the memory address of an existing variable, which they had to initialize appropriately. They did not allocate any memory for their parameter. The copystudent() function should have allocated memory for its Student parameter’s name, but the Student parameter itself was not allocated in the function, because the caller created it. init() here may have to allocate memory for the priority queue data structure, but the variable that its parameter pq points to already exists so should not itself be allocated. 4 Section 3.11 below discusses what sequences of calls to the functions are valid. 3.3 int enqueue(Priorityqueue const pq, const char newelement, int priority) This function should store newelement, which has priority priority, in its parameter priority queue, and return 1. Exactly what it needs to do depends entirely on how you decide to implement priority queues. In this project a priority queue cannot contain two elements that have the same priority, so if there is already an element present with priority priority in the parameter priority queue, the function should just return 0 without modifying the priority queue, otherwise it should return 1 after adding the element to the queue. (Although duplicate elements are not prohibited, elements with duplicate priorities are prohibited.) The function must copy its parameter newelement into a newly–created dynamically–allocated array (meaning a deep copy)of size just sufficient to store the string. This ensures that the string, regardless of its size, is stored without wasting memory space. It also ensures correctness if the memory holding the argument array is later modified or freed by the user of these functions. 3.4 int isempty(const Priorityqueue pq) This function should return 1 if there are no elements currently being stored in its parameter priority queue,and 0 if there are any elements being stored. 3.5 int size(const Priorityqueue pq) This function should return the number of elements being stored in its parameter priority queue, which will always be zero or more. 3.6 char dequeue(Priorityqueue const pq) This function should remove the element in its parameter pq that has the highest priority and return it (meaning a pointer to it, since each element being stored is just a string). The element will no longer be stored in the queue afterwards, and the number of elements being stored will decrease by one. But if pq is currently empty the function should just return NULL instead. 3.7 void clear(Priorityqueue const pq) This function should remove all elements from its parameter pq, so it doesn’t contain any elements; its size will be zero afterwards. As mentioned above, it does not have to free the memory of any elements being removed. (Section 3.11 below discusses what sequences of calls to the functions are valid.) 5 3.8 char getallelements(Priorityqueue pq) This function should return a newly–created dynamically–allocated array (meaning a deep copy) of pointers to characters, that point to newly–created dynamically–allocated copies of the elements being stored in its parameter pq; that is, the pointers in the returned array should not be aliases of the strings stored somewhere in your priority queue data structure. The elements (strings) should appear in the array in order of decreasing priority, with the element that has highest priority first. If there are n elements in the queue pq, the array returned by the function must be an array with n + 1 elements, where the last element must be NULL. This allows the user of your functions to iterate over the elements of the array, stopping when the NULL pointer is reached. (So if the queue has no elements the function must return an array of one element, which will be NULL.) Notice that the form of the array of strings returned is exactly the same as the format of the arrays that checkstringarrays() (described in Section 3.10 below) operates upon. To facilitate program development you may want to write your own helper method that prints the elements of an array of strings, like the one that is returned by this function. (Of course you can also easily view it in the debugger.) But note that our tests that call this function all use the last one below (checkstringarrays()) to check its results, so you may want to write that one even before this one. 3.9 int removeelementsbetween(Priorityqueue const pq, int low, int high) This function should remove all elements from its Priorityqueue parameter whose priority is greater than or equal to the value of low, and less than or equal to the value of high. If no elements at all are removed (because there are no elements in the rangelow…high) the function should just return 0 without changing anything. Otherwise it should return 1 after removing all such elements. Note that there may be any number of zero or more elements that are removed, up to all of the elements in the queue. Also note that there do not have to be elements with exact priorities low and high; any elements whose priorities lie between their values (inclusive) should be removed. 3.10 int checkstringarrays(char names, char expectednames) All of the other functions must be written in pq.c except this one, which must be check-string-arrays.c. This function is a utility function for checking the results of the function getallelements() above. It will be passed two arrays of strings (pointers to characters). It may assume that both arrays will always end with a NULL pointer. (For example, if there are three pointers to strings in one of the arrays the array will actually have four elements, the pointers pointing to the three strings, followed by a NULL pointer.) It should return 1 if the arrays have the same number of 6 strings (elements) before their NULL pointers and exactly the same identical strings (meaning exactly the same in spelling, capitalization, and any spacing), in the same order. It should return 0 in any other case. As described in Section 3.1 above, this function, like any others that have a pointer or array parameter and have an integer return value, should just return 0 without changing anything if either of its pointer parameters is NULL. 3.11 Valid sequences of calls to the functions All valid sequences of calls to your functions on a Priorityqueue variable must obey the following: • init() must be the first function called on any Priorityqueue variable. • After clear() is called on a Priorityqueue variable any of the other functions may be called on that variable, but only if init() is called again on that variable before any of the other functions. The effect of any sequence of calls to the functions that does not have these properties is undefined. Ensuring that these properties are not violated is the responsibility of the caller of your functions; your code does not have to detect violation of these properties (and in fact it has no way to do so). If these properties violated, the effect is just undefined. This means that your code can do anything in that case, including working perfectly or failing spectacularly. (Note that failing is much easier to accomplish.) A Development procedure review A.1 Obtaining the project files, compiling, checking your results, and submitting Log into the Grace machines and use commands similar to those from before: cd tar -zxvf This will create a directory project6 that contains the necessary files for the project, including the two header files pq.h and check-string-arrays.h, and the public tests. You must have your coursework in your course disk space for this class. Create one file in the project6 directory named pq.c (spelled exactly that way) that will #include the header file pq.h, and in it write the functions whose prototypes are in pq.h. (Of course the functions will depend on the type definitions that you first have to write in pq-datastructure.h.) Also create another file there named check-string-arrays.c that will #include check-string-arrays.h, and in it just write the single function checkstringarrays(). 7 (Note that pq.c should #include pq.h but not #include check-string-arrays.h, because it does not use anything defined in it (it does not need to call checkstringarrays() anywhere). Similarly, checkstring-arrays.c should not #include pq.h.) A command like gcc public01.c pq.c -o public01.x will compile your program for the first public test (or you can use Emacs to compile if desired); replace the 1s in the command with 2s for the second public test, etc. You can also use separate compilation, compiling each source file to form object files, which are then linked together. However, note that one of the public tests (the twelfth one) doesn’t use anything in pq.c– it only calls checkstringarrays()– so it only needs to be compiled check-string-arrays.c. And the last two tests call functions from both pq.c and check-stringarrays.c, so they need to be compiled with both of them. As before, use diff to compare your program’s output to the public test outputs that are in the project tarfile, for example public01.x | diff - public01.output will test your code’s results on the first public test. Running submit from the project directory will submit your project, but before you submit you must make sure you have passed all the public tests, by compiling and running them yourself. Unless you have versions of all required functions that will at least compile, your program will fail to compile at all on the submit server. (Suggestion– create skeleton versions of all functions when starting to code, that just have an appropriate return statement.) A.2 Grading criteria Your grade for this project will be based on: Well more than half of your score will come from secret tests. The public tests check only a small subset of the functionality of this project. If you don’t write extensive tests of your functions yourself you could lose significant credit on the secret tests, and wind up with a low score. public tests 30 points secret tests 70 points 8 Project–specific requirements, suggestions, and other notes To summarize, your program consists of three required user–written files: pq-datastructure.h, pq.c, and check-string-arrays.c. Be sure to reread the data structure requirements in Section 2. Recall that the beginning of Section 3 says what the functions should do if any of their parameters are NULL. As mentioned above your functions do not have to free any memory. Note that during the time this project is assigned, the TAs will be explaining valgrind in discussion section. This is a UNIX tool that helps find memory problems in C programs, in particular, it can help detect errors using dynamically– allocated memory incorrectly. If you think your code may have memory problems you can use valgrind, but since you are not required to free memory, you can ignore any memory leaks that it identifies. Any other memory problems that it indicates are things that probably should be fixed. Be careful not to have any pointer aliasing in writing your functions. Do not write code (loops) that has the same effect as any string library functions. If you need to perform an operation on strings and there is a string library function already written that accomplishes that task, you are expected to use it, otherwise you will lose credit. You may lose credit if you cast the return value of the memory allocation functions. Besides being completely unnecessary, in some cases this can mask certain errors in code. You cannot modify anything in the header files pq.h or check-string-arrays.h, or add anything to them, because your submission will be compiled on the submit server using our versions of these files. You cannot write any new header files of your own either. Your code may not comprise any source (.c) files other than pq.c and check-string-arrays.c, so all your code must be in these files. Do not write a main() function in pq.c or check-string-arrays.c, because your code won’t compile (our tests already have main() functions). Write any tests in your own separate source files, and compile them together with pq.c or check-string-arrays.c (or both, depending on what functions your tests are calling). You can only use the C language features that have been covered in class up through Chapter 11 in the Reek text. 9 For this project you will lose one point from your final project score for every submission that you make in excess of five submissions. You will also lose one point for every submission that does not compile, in excess of two noncompiling submissions. Therefore be sure to compile, run, and test your project’s results before submitting it. We hope everyone will check their code themselves carefully, and not incur these penalties. ##Academic integrity Please carefully read the academic honesty section of the syllabus. Any evidence of impermissible coopera- tion on projects, use of disallowed materials or resources, publicly providing others access to your project code online, or unauthorized use of computer accounts, will be submitted to the Office of Student Conduct, which could result in an XF for the course, or suspension or expulsion from the University. Be sure you understand what you are and what you are not permitted to do in regards to academic integrity when it comes to projects. These policies apply to all students, and the Student Honor Council does not consider lack of knowledge of the policies to be a defense for violating them. More information is in the course syllabus– please review it now. The academic integrity requirements also apply to any test data for projects, which must be your own original work. Exchanging test data or working together to write test cases is also prohibited.    </p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1 Introduction and purpose In review: a priority queue is a queue that stores elements that each have an associated priority. In this project the elements themselves will just be strings, and their priorities will be nonnegative integers. Regardless of the order that the elements were added to a priority queue, when an element is removed it is always the element being st&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2 Project description</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000015/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000015/</id>
    <published>2018-11-04T09:21:10.000Z</published>
    <updated>2018-11-04T09:24:02.204Z</updated>
    
    <content type="html"><![CDATA[<p>Project description • It will have to read data from its input until the end of the input is seen. It will need to</p><a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>1 2 Project description • It will have to read data from its input until the end of the input is seen. It will need to do this one line at a time, because it will need to count the characters in each line. A line is just an abstraction; it is a sequence of zero or more characters followed by the special newline character, so your program must look for a newline to determine where a line that it is reading ends. • It will need to print the characters in each line that was read, but before that it will have to store the characters of each line into a one–dimensional array as they are being read. The program can’t just print the characters as they are read, because before each line is printed an indication has to be displayed if the line is too long (i.e., if it has more than 80 characters). Consequently, an entire line must be read so its length can first be determined, then it is printed. Note that its terminating newline indicates where an input line ends, but it is not part of the line’s contents, so it does not count towards its length. Each line’s length can be determined either during the process of reading it, or after it has been read. • The first thing printed on each output line, in the first column or character position, must either be a single blank space character if the current line that was just read is 80 characters or less, or a single asterisk () if the line read is longer than 80 characters. • The next thing printed on each output line must be the number of the current line (the first line read is line #1). Your program’s input will never contain more than 2 99999 lines, so the line number should be printed in a field of exactly 5 places, padded on the left with blank spaces if it is less than 5 digits. (Note that this formatting can trivially be performed in C with the right printf() formatting options, explained in a recent discussion section.) • Following the line number a colon should be printed, followed by a single blank space, then the characters of the line that was read, followed by a newline. The actual input line as printed will always begin in the ninth column or output position, because the space or asterisk, line number, colon, and following space all occupy the first eight positions. • An additional line of output is to be printed only for input lines longer than 80 characters. Immediately following the line a second line must be printed, having exactly 88 blank spaces, then enough caret characters (^) so there is a caret underneath each position of the line that is beyond the 80th position. See the example below. (88 blank spaces includes 80 for the characters of the line that are within the first 80 positions, plus as mentioned 8 for the asterisk or space, line number, colon, and space.) Note that the input to your program could be anything – it doesn’t even have to be a C program. But if you run it reading its own code, it will tell you whether it has any lines longer than 80 characters, which you would definitely lose credit for during grading. Here is an example of the output that should be produced for a single input line that is exactly 85 characters long, with blank spaces shown as ␣: ␣␣␣␣1:␣This␣is␣a␣line␣with␣85␣characters.␣␣(Words␣were␣chosen␣carefully␣to␣have␣exactly␣85.) ␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣^^^^^ 3 2.1 Tab characters As described above the program is straightforward, although you may encounter a few issues due to differences between C and Java that this project is intended to bring up. But a slightly tricky issue is the effect of any tab characters in the input. When we said that program lines longer than 80 characters should be indicated we were really referring to how they would appear on the screen or printer, not how many characters they actually contain, because a tab character appears to occupy anywhere between 1 and 8 positions. Output devices act as if there was an invisible tab stop at every eighth character position (the eighth position, sixteenth, etc.) The effect of printing a tab character is to cause output to skip just past the next tab position. (Consequently, a character in the input immediately following a tab will appear right after the next tab position.) Because your program has to determine how long each input line would appear when displayed, tabs in its input have to be counted as the equivalent of however many spaces would be necessary to skip over to the next tab stop, given the contents of the line before the tab character (which may itself contain tabs). For example: • If an input line contained the three characters cat followed by a tab character and then bat, it would appear to be 11 characters when printed, even though there are actually only seven real characters in the line. cat would obviously be printed in the first three positions of the output device, then the tab character would cause the rest of the output to begin at the ninth position, so bat would be in the ninth through eleventh positions. In this case we will refer to 11 as the size of the line. 4 • If a line contained hi followed by a tab followed by 216 followed by another tab and then bye, its size would be 19 – hi is two characters, the tab advances to the next tab stop so it would appear as if it were six characters, 216 is three characters, the next tab would appear as if it were five characters, and bye is three characters. • And if a line contained two consecutive tab characters followed by the characters hamster, the first tab would advance to the eighth position and the second tab would advance to the sixteenth position, so the h would be at the seventeenth position, the a at the eighteenth, etc., and its size is 23. Size is only different from the actual number of characters in a line when the line contains tabs. A tab character always appears as if it occupies at least one space. Suppose a line had eight characters, a tab, and a Z. After the first eight characters are printed the output device will be at the ninth position, but the Z cannot appear there, because if it did the tab would not be visible at all. Instead the tab causes printing to advance eight spaces, and the Z would be at the seventeenth position. For lines with size longer than 80, consecutive caret characters should be printed from the 81st position up through the line’s size. For example, if a line had 80 Xs followed by two tabs its effective length would be 96, so 88 spaces then 16 carets would be printed on the line underneath it. Note lastly that although a tab character may appear to occupy multiple spaces in an output line, your program should print the characters of lines exactly as they were read from the input, so any tab characters should be printed as tabs. Do not replace them by spaces. (We could have said to replace tabs by spaces, but it would involve some complexities that are not immediately apparent; in any event, the submit server is expecting all tabs to be printed as tabs in order to say that your output is correct.) 2.2 5 • Notes, constraints, and allowable language features You are guaranteed that every line in your program’s input, even the last one, will always end with a newline character. When you create input data files of your own with Emacs to test your program with, be sure to press return at the end of the last line you type, so they will also end in a newline. Our input data may contain any printable characters appearing on a standard US keyboard, but for simplicity we will avoid nonprintable or whitespace characters other than tabs and newlines. Any line in the input may have more than than 80 characters, but you may assume there will be no more than 1000 characters (any of which may be tabs) prior to the terminating newline character of any line. As above, there will be no more than 99999 lines in the program’s input. Since there can be up to 99999 lines in your program’s input, it would use a lot of memory to try to read the entire input in at once. (In fact, your program may crash if you do that, due to using too much memory.) Just read and process one line (up until its trailing newline) at a time. All of your code must be in the single file linecheck.c. Do not create any new source or header files for the project. You must implement this project using only the features of C that have been covered so far in class this semester. We want you to practice using these features before going on to new ones. The project can probably be written more easily using features we haven’t covered yet, but one purpose of the project is to get experience with some of the differences between Java and C that the project will illustrate if written as specified. In particular: – The only library header file your program can include is stdio.h, – The only C library functions your program can call are printf(), scanf(), and feof(), 6 – The only format specifiers that your program can use are the ones covered so far in class (%d, %c, %f, %o, %u, and %x), – Even if you know something about using strings in C already, do not attempt to use strings in C (which also have not been covered), and – Even though Chapter 1 in the Reek text uses various C features that have not been covered in class yet, you may not use them if they were not also covered in class. You will lose significant credit when your project is graded if you use C features that weren’t covered yet. The project can be written in a small number of lines of code using just features covered so far.    </p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Project description • It will have to read data from its input until the end of the input is seen. It will need to&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSIT815 Data Management and Securit</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000014/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000014/</id>
    <published>2018-11-04T09:17:21.000Z</published>
    <updated>2018-11-04T09:20:24.812Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写<br>java代写<br>python代写<br>MATLAB代写<br>作业代写</p><a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>CSIT815 Data Management and Security<br>School of Computing and Information Technology Session: Autumn 2018 University of Wollongong Lecturers: Janusz R. Getta Tianbing Xia CSIT815 Data Management and Security Project 19 March 2018 Scope This project addresses the problems in database design, database implementation, and data security. Important messages Please read the messages listed below before implementation of the tasks included in a specification of the project. More implementation related information can be found in “How to … ?” Cookbook available through Moodle or at: <a href="http://www.uow.edu.au/~jrg/115/COOKBOOK" target="_blank" rel="noopener">http://www.uow.edu.au/~jrg/115/COOKBOOK</a>. The outcomes of the project are due by Saturday, 2 June, 2018, 10.00 pm sharp. The project contributes to 4% of the total evaluation in the subject. A submission procedure is explained at the end of this document. Only one submission of the project is allowed and only one submission per student is accepted. Please make sure that you submit the correct files. A submission that contains an incorrect file attached is treated as a correct submission with all consequences coming from the evaluation of the file attached. Compressed (zipped, rared, tared, etc) files will not be evaluated. A submission marked by Moodle as “late” is treated as a late submission no matter how many seconds it is late. The reports from processing of SQL scripts must return NO ERRORS ! A solution with the errors is worth no marks ! A policy regarding late submissions is included in CSIT115/815 Subject Outline. Tasks Task 1 (1 mark) Consider the following specification of a sample database domain. A transportation company provides door-to-door delivery of parcels and needs a database to keep track of the business activities. The company uses an infrastructure based on the public transportation model. The customers submit the parcels to safe storage containers set up at railroad stations and thousands of other places across the country. Each parcel obtains a unique bar code, which is automatically scanned when a parcel is dropped into a container. Vehicles travel over the route segments, pick up the parcels from the containers and either leave the parcels in another container or deliver the parcels to the destinations. The database must contain information about: • All route segments, described by a unique segment number and a length. One route segment may span over several roads. Each road has a unique road identifier and it is described by the names of cities located at its endpoints. • All endpoints of route segments, including their geographical coordinates (longitude and latitude). A pair of endpoints also uniquely identifies a route segment. A route segment is connected to zero or more other route segments at its endpoint. • The name and address of each customer that has ever used the service. More than one customer may reside at any address. • The vehicles owned by the company. For every vehicle, the type and model name, along with information on carrying capacity, and mileage. The registration number is unique for each vehicle. • Name and driver license number of every driver. • For each safe storage container, its geographical coordinates (longitude and latitude), capacity, and the date it was put to use. Storage containers are located along and at the connections of route segments. • Information about every parcel, including the customer who ordered the shipping, shipping price, order date, delivery address, and the unique bar code. • Information about the present location of each parcel. The location of a parcel is either the location of safe storage container or the location of a vehicle used for transportation of a parcel. • Information about present location of each vehicle and its driver. Location of a vehicle includes its geographical coordinates (longitude and latitude) and the route segment currently travelled. The company expects that it will later extend the descriptions of customers and parcels with more specific attributes. Your design must be constructed such that there will be no need to change it in the future no matter and what and how many attributes are added. Design a conceptual schema for the database, which will keep information about World Tour Championships in Greasy Pole Climbing (WTC-GPC) competitions. Use the notation of simplified UML class diagrams explained during the lecture classes and applied for conceptual modeling in the laboratories and assignments. Remember to determine the multiplicities of associations, identifiers of classes of objects, multivalued, optional and derived attributes (if any). Make sure that a schema of your database does not contain redundancies and it correctly represents all information that should be included in the database. You are allowed to apply any design methodology, which is the most convenient for you. Only the final conceptual schema is expected and there is no need to show a design process. You are allowed to add more realworld attributes to the design, however, it is NOT allowed to add any artificial attributes, which do not exist in the reality, like for example addressID or vehicleID, etc. You are also allowed to decide on the identifiers of classes, however your choice must be consistent with the reality. Use UMLetlet to draw a conceptual schema of the designed database and when ready export it to a file solution1.pdf. Deliverables A file solution1.pdf with the final design of a conceptual schema. Task 2 (1 mark) Perform a logical design to convert a conceptual schema created in the previous task into a collection of relational schemas and next implement SQL script task2.sql that to create the relational tables. Next, include into a script task2.sql SQL statements that insert from 3 to 5 rows into each one of the relational tables created. Finally, add to your script SELECT statements that list the contents of all relational tables in the database. Execute a script file task2.sql and save a report from processing of the script in a file solution2.rpt. Deliverables A file solution2.rpt with a report from processing of SQL script task2.sql. Task 3 (1 mark) Create SQL script task3.sql that implement the following queries. All constants in SELECT statements are up to you, however, the constants must be selected such that all queries return nonempty answers. It also means, that you may have to return to the previous task to add more rows to the relational tables. (1) List full information about a selected route segment. The selected route segment must span over at least 2 roads. List the descriptions of roads the selected route segments spans on. (2) List the names of drivers who passed through a given route segment at least 2 times. (3) List the names and addresses of the customers together with the total number of times each one of them was used transportation service. (4) List full description of vehicles that have not been used for any service yet. (5) List the locations of storage containers together with the full descriptions of parcels stored in each container. Execute a script file task3.sql and save a report from processing of the script in a file solution3.rpt. Deliverables A file solution3.rpt with a report from processing of SQL script task3.sql. Task 4 (1 mark) Assume that the managers of the transportation company are divided into the following groups: mngmt, admin, and driver. Implement SQL script task4.sql that creates three users such that one user belongs to a group mngmt, one user belongs to a group admin, and one user belongs to a group driver. A group mngmt must have read and write access rights on all relational tables in a database. A group admin must have read access rights on all relational tables in a database and write access right on the relational tables that included information about customers and parcels. A group driver must have read access rights on all tables excluding the tables that contain information about customers and read and write access rights on all tables that contain information about trucks, parcels, and storage containers. Add to SQL script task4.sql the statements that implement access control system described above and execute a script task4.sql. Save a report from processing of a script task4.sql in a file solution4.rpt. Deliverables A file solution4.rpt with a report from processing of SQL script task4.sql. Submission Note, that you have only one submission. So, make it absolutely sure that you submit the correct files with the correct contents. No other submission is possible ! Submit the files solution1.pdf, solution2.rpt, solution3.rpt, and solution4.rpt through Moodle in the following way: (1) Access Moodle at <a href="http://moodle.uowplatform.edu.au/" target="_blank" rel="noopener">http://moodle.uowplatform.edu.au/</a> (2) To login use a Login link located in the right upper corner the Web page or in the middle of the bottom of the Web page (3) When logged select a site CSIT815/CSIT115 (S117) Data Management and Security (4) Scroll down to a section Submissions (5) Click at a link In this place you can submit the outcomes of Project(CSIT815 students only) (6) Click at a button Add Submission (7) Move a file solution1.pdf into an area You can drag and drop files here to add them. You can also use a link Add… (8) Repeat step (7) for the files solution2.rpt, solution3.rpt, and solution4.rpt. (9) Click at a button Save changes (10)Click at a button Submit assignment (11)Click at the checkbox with a text attached: By checking this box, I confirm that this submission is my own work, … in order to confirm the authorship of your submission (12)Click at a button Continue It is expected that all its tasks included within the project will be solved individually without any cooperation with the other students. If you have any doubts, questions, etc. please consult your lecturer or tutor during lab classes or office hours. Plagiarism will result in a FAIL grade being recorded for that assessment task. End of specification    </p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写&lt;br&gt;java代写&lt;br&gt;python代写&lt;br&gt;MATLAB代写&lt;br&gt;作业代写&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写" scheme="http://holydudecs.github.io/tags/c-c-%E4%BB%A3%E5%86%99-java%E4%BB%A3%E5%86%99-python%E4%BB%A3%E5%86%99-matlab%E4%BB%A3%E5%86%99-%E4%BD%9C%E4%B8%9A%E4%BB%A3%E5%86%99-%E7%95%99%E5%AD%A6%E7%94%9F%E4%BD%9C%E4%B8%9A%E4%BB%A3%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>Project 2, Semester 2, 2018</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000013/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000013/</id>
    <published>2018-11-04T09:15:42.000Z</published>
    <updated>2018-11-04T09:20:39.880Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写<br>java代写<br>python代写<br>MATLAB代写<br>作业代写</p><a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. The University of Melbourne School of Computing and Information Systems SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Released: Saturday 8th of August Project 2A Due: Saturday 22nd of September, 11:59pm Project 2B Due: Friday 12th of October, 11:59pm Overview In this project, you will create a graphical arcade game in the Java programming language, continuing from your work in Project 1.1 The graphics will be handled using the Slick graphics library. This is an individual project. You can discuss it with other students, but all submitted code must be your own work. You can use any platform and tools you like to develop the game, but we recommend using the Eclipse IDE, since that is what we are supporting in class. You will not be required to design any aspect of the game itself; this document should provide all necessary information about how the game works. You will, however, be required to design the classes for your software solution before you implement it. There are two parts to this project, with different submission dates. The first task, Project 2A, requires that you produce a class design demonstrating how you plan to implement the game. This should be submitted in the form of a UML diagram showing all the classes you plan to implement, the relationships (e.g. inheritance and associations) between them, and their attributes, as well as their primary public methods. (Methods such as getters and setters need not be explicitly included.) If you so choose, you may show the relationships in a separate document to the class members, but you must use correct UML notation. Please submit in PDF format only. The second task, Project 2B, is to complete the implementation of the game as described in the rest of this specification. You do not have to follow your class design; it is only there to encourage you to think about object-oriented principles before you start programming. 1We will be providing a full working solution for Project 1 at a later date. You are welcome to use all or part of it, with appropriate attribution. 1 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. Shadow Leap Game overview Shadow Leap is an arcade game where the player must correctly time their leaps to guide the frog to the other side of the road and river, while avoiding falling into the river or getting run over by cars. The game is divided into vehicles, tiles, and rideable objects. Below I will outline the different game elements you need to implement. The player The player behaves similarly to Project 1. A new addition is solid tiles, including the tree tile and the bulldozer; the player should not be able to move into these tiles. The player also now has lives. The player starts with three lives, and when the player makes contact with a hazard such as a vehicle or water, the player loses a life, reducing the lives counter by one and resetting the player’s position to the initial position. If the player loses a life when there are zero remaining, the game should end. The lives remaining should be displayed in the bottom-left using the image lives.png; the first icon should be drawn at the position (24,744), and each additional icon should be drawn 32 pixels to the right of the previous. The empty tiles at the top of the screen are your goal. When the player reaches these tiles, the space should be filled with a frog sprite centred in the gap. 2 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. When this occurs, the player should reset to its initial position. When all holes are filled, the game should proceed to the next level as detailed below. If the player attempts to fill a hole that has already been filled, the player should instead lose a life. The levels The data for the objects in the game is stored in a comma-separated value format. Each line corresponds to either a tile or a moving object. A tile is described by a name, an x coordinate, and a y coordinate. An example is provided below: water,0,96 In this case, a water tile should be created at the position (0,96). A moving object is described by a name, an x coordinate, a y coordinate, and a boolean value that indicates if the object should move to the right. An example is provided below: bus,48,432,false In this case, a bus object should be created at the position (48,432), and it should move towards the left. When a level is loaded, each line of the CSV file should be interpreted in this way, and then the player should be created at the position (512,720). The first level is named 0.lvl, and the second level is named 1.lvl. If the next level is reached after the second level, the game should end. The moving objects Moving objects move at a constant speed across the screen, either left or right. All moving objects have the property that when they are completely off screen on one side, they should reappear at the other side of the screen, so that they are just barely not visible. The moving objects are divided into vehicles and rideable objects. There are four kinds of vehicles. Unless otherwise indicated, the player should lose a lief when they make contact with a vehicle. 3 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. • The bus: The bus behaves as in Project 1. It moves at a rate of 0.15 pixels per millisecond. • The racecar: The racecar behaves the same way as the bus, except it moves at a rate of 0.5 pixels per millisecond. • The bike: The bike moves at a rate of 0.2 pixels per millisecond. When the bike reaches an x coordinate of either 24 or 1000, the bike should reverse direction. • The bulldozer: The bulldozer moves at a rate of 0.05 pixels per millisecond. The bulldozer is a solid object; instead of causing the player to lose a life, the bulldozer should instead push the player in its direction of travel at a a rate of 0.05 pixels per millisecond. If the bulldozer were to push the player off the screen, the player should lose a life instead. There are three kinds of rideable objects; when the player is on top of these, they should not lose a life for making contact with the water. The player should also move along with the rideable object at the same speed as the object. When the rideable object moves off the screen, the player should remain at the edge of the screen until the rideable object disappears, at which point the player should lose a life. • The log: The log moves at a rate of 0.1 pixels per millisecond. • The long log: The long log moves at a rate of 0.07 pixels per millisecond. • The turtles: The turtles move at a rate of 0.085 pixels per millisecond. Every 7 seconds, the turtles should disappear underwater and not be displayed on screen; when they are not visible, they do not protect the player from the water. After 2 seconds underwater, they should resurface and be visible again. 4 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. The extra life The last component of the game is the extra life object: At the beginning of the game, a random number of seconds between 25 and 35 should be chosen. When this time has passed, a random log or long log object should be chosen, and an extra life object should be created at the same position as the chosen log object. This process should then repeat. The extra life object moves along with the log object it is on top of; when the log disappears from one side and reappears at the other side, the extra life should follow the log. When the player makes contact with the extra life object, it should be destroyed and the player should gain a life. The last feature of the extra life object is that it should move around on its log. It should first attempt to move right, one tile every 2 seconds. When it can no longer move to the right, it should move to the left at the same rate, and so on. After 14 seconds the extra life object should disappear. Implementation checklist This project may seem daunting. As there are a lot of things you need to implement, we have provided a checklist, ordered roughly in the order we think you should implement them in. Each feature comes with a number of marks that it is worth. 1. Vehicles are loaded and can hit the player (1) 2. All vehicles move correctly (0.5) 3. The bulldozer pushes the player (0.5) 4. The player moves along with the rideable objects (1) 5. The frog hole correctly shows when it has been reached (0.5) 6. The level completes when all holes have been reached and the next level begins (0.5) 7. The number of lives is correctly displayed (0.5) 8. The player loses a life when they make contact with a hazard (0.5) 9. The game ends when lives run out (0.5) 10. The turtles follow the correct timing of sinking and resurfacing (0.5) 11. The extra life object is generated with the correct timing (1) 12. The extra life object moves correctly and gives an extra life (1) 5 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. Customisation Optional: we want to encourage creativity with this project. We have tried to outline every aspect of the game design here, but if you wish, you may customise any part of the game, including the graphics, types of obstacles, variety of levels, etc. You can also add entirely new features. However, to be eligible for full marks, you must implement all of the features in the above implementation checklist. For those of you with far too much time on your hands, we will hold a competition for the best game extension or modification, judged by the lecturer and tutor. The winning three will be demonstrated at the final lecture, and there will be a prize for our favourite. Past modifications have included drastically increasing the scope of the game, implementing jokes and creative game design, adding polish to the game, and even introducing networked gameplay. If you would like to enter the competition, please email the head tutor, Eleanor McMurtry, at <a href="mailto:mcmurtrye@unimelb.edu.au" target="_blank" rel="noopener">mcmurtrye@unimelb.edu.au</a> with your username and a short description of the modifications you came up with. I can’t wait to see what you’ve done! The supplied package You will be given a package, oosd-project2-package.zip, which contains all of the graphics and data you need to create the game. Submission and marking Submission will be through the LMS. Please submit your entire project folder, including resources and all code. Note that all public methods, attributes, and classes should have Javadoc comments, as explained in later lectures. You are not required to actually generate the Javadoc. Good Coding Style Good coding style is a contentious issue; however, we will be marking your code based on the following criteria: • You should not go back and comment your code after the fact. You should be commenting as you go. • You should be taking care to ensure proper use of visibility modifiers. Unless you have a very good reason for it, all instance variables should be private. • Any constant should be defined as a static final variable. Don’t use magic numbers! • Think about whether your code makes assumptions about things that are likely to change for Project 2. 6 SWEN20003 Object Oriented Software Development Project 2, Semester 2, 2018 Updated 2nd Oct. • Make sure each class makes sense as a cohesive whole. A class should contain all of the data and methods relevant to its purpose. Extensions and late submissions If you need an extension for the project, please email Eleanor at <a href="mailto:mcmurtrye@unimelb.edu.au" target="_blank" rel="noopener">mcmurtrye@unimelb.edu.au</a> explaining your situation with some supporting documentation (medical certificate, academic adjustment plan, wedding invitation). If an extension has been granted, you may submit via the LMS as usual; please do however email Eleanor once you have submitted your project. The project is due at 11:59pm sharp. As soon as midnight falls, a project will be considered late unless an extension has been granted. There will be no exceptions. There is a penalty of 2 marks for the first day a project is submitted late, plus 1 mark per additional day. If you submit late, you must email Eleanor with your student ID and number so that we can ensure your late submission is marked correctly. Marks Project 2 is worth 22 marks out of the total 100 for the subject. • Project 2A is worth 6 marks. – Correct UML notation for methods (1 mark) – Correct UML notation for attributes (1 mark) – Correct UML notation for associations (1 mark) – Good breakdown into classes (1 mark) – Sensible approach to association (1 mark) – Appropriate use of inheritance (1 mark) • Project 2B is worth 16 marks. – Features implemented correctly: 8 marks (see Implementation checklist for details) – Coding style, documentation, and good object-oriented principles: 8 marks ∗ Delegation: breaking the code down into appropriate classes (2 marks) ∗ Use of methods: avoiding repeated code and overly complex methods (1 mark) ∗ Cohesion: classes are complete units that contain all their data (1 mark) ∗ Coupling: interactions between classes are not overly complex (1 mark) ∗ General code style: visibility modifiers, magic numbers, commenting etc. (1 mark) ∗ Use of documentation (javadocs) (1 mark) 7    </p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写&lt;br&gt;java代写&lt;br&gt;python代写&lt;br&gt;MATLAB代写&lt;br&gt;作业代写&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CS 120 Project 4</title>
    <link href="http://holydudecs.github.io/2018/11/04/Task000012/"/>
    <id>http://holydudecs.github.io/2018/11/04/Task000012/</id>
    <published>2018-11-04T09:13:28.000Z</published>
    <updated>2018-11-04T09:20:51.224Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写<br>java代写<br>python代写<br>MATLAB代写<br>作业代写</p><a id="more"></a><p>c/c++代写,java代写,python代写,matlab代写,作业代写,留学生作业代写</p><p>S 120 Project 4 Due on Blackboard by Friday, October 19th For this project, you will design, implement, and use optionals, namespaces, file I/O and C++ classes with polymorphism. Requirements • All of your programming files should be in a private GitHub repository in the UVMCS120F2018 organization. • You may reuse the repository from a previous project if appropriate. • Your repository should have a .gitignore file and a README file. • In a header file (or files) declare at least three classes, where one class is an abstract base class and the other two classes extend it. Why did you choose these classes? What method(s) did you make pure virtual and why did that make sense? • You need to use at least two namespaces in your program. Why did you choose these namespaces? Justify the way you access them in your main program. • You must test all nontrivial methods from your classes. Create a testing.cpp that has a main function and put an add_executable line in CMakeLists.txt to create an executable for testing. • You need to write a fully functioning, interactive, and impressive main program. Create a main.cpp and put an add_executable line in CMakeLists.txt to create an executable for your main program. • You must use at least one optional in your program. It can be used as a field of a class or as a variable in your main function. Justify using an optional for this variable. Why does it make sense to use with objects of your classes? • You must include file I/O in your program. You can read from a file, write to a file, or both. You can include this in a method of a class or in a global function to be used in your main program. Why did you choose this functionality and how does it make sense to use with your program? • You must demonstrate polymorphism in your main program. Why did you choose this demonstration of polymorphism? • In your README file, you should write answers to all of the above questions and prompts. • All of the above must be pushed to your GitHub repository. • On Blackboard, submit the URL of the last commit. Grading The project is out of 80 points. 5 pts Project compiles and runs. GitHub repository includes all files as described above. 5 pts Good, consistent coding style throughout project. 15 pts Declared and defined at least three classes as described above. 5 pts Nontrivial methods are fully tested. 6 pts Declared and used at least two namespaces. 4 pts Declared and defined at least one optional. 10 pts Included file I/O in your program. 10 pts Main function uses all items declared and demonstrates polymorphism. 10 pts Main program is fully functional and impressive. 5 pts All user input is validated. 5 pts The README file contains all that is described above.    </p><p>留学生作业代写,cs作业代写,cs代写,作业代写,北美cs作业代写,澳洲cs作业代写,加拿大cs作业代写,cs作业代写价格,靠谱cs作业代写,程序代写<br><img src="images/wechat.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写&lt;br&gt;java代写&lt;br&gt;python代写&lt;br&gt;MATLAB代写&lt;br&gt;作业代写&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c/c++代写 数据结构算法 splayTree实现</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000011/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000011/</id>
    <published>2018-09-29T13:02:19.000Z</published>
    <updated>2018-11-04T09:03:24.111Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写 数据结构预算法:在老师给的class基础上再完成splayTree,cacheLRU<br><a id="more"></a></p><p>#ifndef splayTree_H_</p><p>#define splayTree_H_</p><p>#include “rotateBST.h”</p><p>using std::cout;<br>using std::endl;<br>using std::max;</p><p>template<typename key,typename="" value=""><br>class rotateBST;</typename></p><p>template<typename key,typename="" value=""><br>class SplayTree:public rotateBST&lt;Key,Value&gt;<br>{<br>    public:<br>        SplayTree()<br>        {<br>            time_left_rotation=0;<br>            time_right_rotation=0;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator find(const Key&amp; key)<br>        {<br>            Node&lt;Key,Value&gt;<em> pre=NULL;<br>            Node&lt;Key,Value&gt;</em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            if(cur-&gt;getKey()==key)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>                return it;<br>            }<br>            pre=cur;<br>            while(cur!=NULL)<br>            {<br>                pre=cur;<br>                if(cur-&gt;getKey()&lt;key)//key is bigger ,go to right<br>                {<br>                    cur=cur-&gt;getRight();<br>                }else if(cur-&gt;getKey()&gt;key)//key is smaller,go to left<br>                {<br>                    cur=cur-&gt;getLeft();<br>                }else {<br>                    splay(cur);<br>                    typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>                    return it;<br>                }<br>            }<br>            splay(pre);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>            return it;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator findMin()<br>        {<br>            Node&lt;Key,Value&gt;<em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            while(cur-&gt;getLeft()!=NULL)<br>            {<br>                cur=cur-&gt;getLeft();<br>            }<br>            splay(cur);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>            return it;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator findMax()<br>        {<br>            Node&lt;Key,Value&gt;</em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            while(cur-&gt;getRight()!=NULL)<br>            {<br>                cur=cur-&gt;getRight();<br>            }<br>            splay(cur);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>            return it;<br>        }<br>        void deleteMinLeaf()<br>        {<br>            Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;<br>            if(cur==NULL) return ;</typename></p><pre><code>        while(cur-&gt;getLeft()!=NULL||cur-&gt;getRight()!=NULL)        {            if(cur-&gt;getLeft()!=NULL)            {                cur=cur-&gt;getLeft();            }else if(cur-&gt;getRight()!=NULL)            {                cur=cur-&gt;getRight();            }        }        remove(cur-&gt;getKey());    }    void deleteMaxLeaf()    {        Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;        if(cur==NULL) return;        while(cur-&gt;getLeft()!=NULL||cur-&gt;getRight()!=NULL)        {            if(cur-&gt;getLeft()!=NULL)            {                cur=cur-&gt;getLeft();            }else if(cur-&gt;getRight()!=NULL)            {                cur=cur-&gt;getRight();            }        }        remove(cur-&gt;getKey());    }    void insert(const std::pair&lt;const Key,Value&gt;&amp; keyValuePair)    {        BinarySearchTree&lt;Key,Value&gt;::insert(keyValuePair);        Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;        Key key=keyValuePair.first;        while(cur-&gt;getKey()!=key)        {            if(cur-&gt;getKey()&lt;key)//key is bigger            {                cur=cur-&gt;getRight();            }else if(cur-&gt;getKey()&gt;key)            {                cur=cur-&gt;getLeft();            }        }        splay(cur);    }    void remove(const Key&amp; key)    {        Node&lt;Key,Value&gt;* pre=removeHelper(key);        splay(pre);    }private:    Node&lt;Key,Value&gt;* splay(Node&lt;Key,Value&gt;* nod,Key k);//stand splay    typename SplayTree&lt;Key,Value&gt;::iterator findHelper(Node&lt;Key,Value&gt;* nod,const Key&amp; key);    Node&lt;Key,Value&gt;* removeHelper(const Key&amp; key)    {        if(this-&gt;mRoot==NULL) return NULL;        Key k=key;        Node&lt;Key,Value&gt;* nod=this-&gt;mRoot;        Node&lt;Key,Value&gt;* pat=NULL;        while(nod)        {            if(nod-&gt;getKey()&lt;k)            {                nod=nod-&gt;getRight();            }else if(nod-&gt;getKey()&gt;k)            {                nod=nod-&gt;getLeft();            }else            {                if(nod-&gt;getLeft()==NULL&amp;&amp;nod-&gt;getRight()==NULL)                {                    if(nod-&gt;getParent()==NULL)                    {                        this-&gt;mRoot=NULL;                        pat=nod-&gt;getParent();                        delete nod;                        nod=NULL;                        break;                    }else                    {                        Node&lt;Key,Value&gt;* p=nod-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(NULL);                            pat=nod-&gt;getParent();                            delete nod;                            nod=p;                            break;                        }else if(p-&gt;getRight()==nod)                        {                            p-&gt;setRight(NULL);                            pat=nod-&gt;getParent();                            delete nod;                            nod=p;                            break;                        }                    }                }else if(nod-&gt;getLeft()!=NULL)                {                    Node&lt;Key,Value&gt;* pre=nod-&gt;getLeft();                    while(pre-&gt;getRight()!=NULL)                    {                        pre=pre-&gt;getRight();                    }                    Node&lt;Key,Value&gt;* sis=new Node&lt;Key,Value&gt;(pre-&gt;getKey(),pre-&gt;getValue(),nod-&gt;getParent());                    sis-&gt;setLeft(nod-&gt;getLeft());                    sis-&gt;setRight(nod-&gt;getRight());                    if(sis-&gt;getParent()==NULL) this-&gt;mRoot=sis;                    else {                        Node&lt;Key,Value&gt;* p=sis-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(sis);                        }else                        {                            p-&gt;setRight(sis);                        }                    }                    Node&lt;Key,Value&gt;* left=nod-&gt;getLeft();                    if(left!=NULL)                    {                        left-&gt;setParent(sis);                    }                    Node&lt;Key,Value&gt;* right=nod-&gt;getRight();                    if(right!=NULL)                    {                        right-&gt;setParent(sis);                    }                    pat=nod-&gt;getParent();                    delete nod;                    k=pre-&gt;getKey();                    if(pre-&gt;getParent()!=sis)                    {                        nod=pre-&gt;getParent();                    }else                    {                        nod=sis-&gt;getLeft();                    }                }else                {                    Node&lt;Key,Value&gt;* suc=nod-&gt;getRight();                    while(suc-&gt;getLeft()!=NULL)                    {                        suc=suc-&gt;getLeft();                    }                    Node&lt;Key,Value&gt;* sis=new Node&lt;Key,Value&gt;(suc-&gt;getKey(),suc-&gt;getValue(),nod-&gt;getParent());                    sis-&gt;setLeft(nod-&gt;getLeft());                    sis-&gt;setRight(nod-&gt;getRight());                    if(sis-&gt;getParent()==NULL) this-&gt;mRoot=sis;                    else {                        Node&lt;Key,Value&gt;* p=sis-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(sis);                        }else                        {                            p-&gt;setRight(sis);                        }                    }                    Node&lt;Key,Value&gt;* l=sis-&gt;getLeft();                    if(l!=NULL)                    {                        l-&gt;setParent(sis);                    }                    Node&lt;Key,Value&gt;* r=sis-&gt;getRight();                    if(r!=NULL)                    {                        r-&gt;setParent(sis);                    }                    pat=nod-&gt;getParent();                    delete nod;                    k=suc-&gt;getKey();                    if(suc-&gt;getParent()!=sis)                    { nod=suc-&gt;getParent();                    }else                    { nod=sis-&gt;getRight();  }                }            }        }        while(nod)        {            Node&lt;Key,Value&gt;* node=nod;            if(node-&gt;getLeft()==NULL&amp;&amp;node-&gt;getRight()==NULL) node-&gt;setHeight(1);            else if(node-&gt;getLeft()==NULL) node-&gt;setHeight(node-&gt;getRight()-&gt;getHeight()+1);            else if(node-&gt;getRight()==NULL) node-&gt;setHeight(node-&gt;getLeft()-&gt;getHeight()+1);            else node-&gt;setHeight(max(node-&gt;getLeft()-&gt;getHeight(),node-&gt;getRight()-&gt;getHeight())+1);            nod=nod-&gt;getParent();        }        return pat;    }    int time_left_rotation;    int time_right_rotation;protected:    void splay(Node&lt;Key,Value&gt;* x)//splay the given node to the root//the r is existed    {        if(x==NULL) return ;        Node&lt;Key,Value&gt;* p=x-&gt;getParent();        if(p==NULL) return ;        Node&lt;Key,Value&gt;* g=p-&gt;getParent();        if(g==NULL)//p is root        {            if(p-&gt;getLeft()==x)            {                rotateBST&lt;Key,Value&gt;::rightRotate(p);                return ;            }else if(p-&gt;getRight()==x)            {                rotateBST&lt;Key,Value&gt;::leftRotate(p);                return ;            }        }        if(g-&gt;getLeft()==p&amp;&amp;p-&gt;getLeft()==x)//left left        {            rotateBST&lt;Key,Value&gt;::rightRotate(g);            rotateBST&lt;Key,Value&gt;::rightRotate(p);            time_right_rotation+=2;        }else if(g-&gt;getLeft()==p&amp;&amp;p-&gt;getRight()==x)        {            rotateBST&lt;Key,Value&gt;::leftRotate(p);            rotateBST&lt;Key,Value&gt;::rightRotate(g);            time_left_rotation+=1;            time_right_rotation+=1;        }else if(g-&gt;getRight()==p&amp;&amp;p-&gt;getRight()==x)        {            rotateBST&lt;Key,Value&gt;::leftRotate(g);            rotateBST&lt;Key,Value&gt;::leftRotate(p);            time_left_rotation+=2;        }else if(g-&gt;getRight()==p&amp;&amp;p-&gt;getLeft()==x)        {            rotateBST&lt;Key,Value&gt;::rightRotate(p);            rotateBST&lt;Key,Value&gt;::leftRotate(g);            time_left_rotation+=1;            time_right_rotation+=1;        }        splay(x);    }</code></pre><p>};</p><pre><code>template&lt;typename Key,typename Value&gt;</code></pre><p>typename SplayTree&lt;Key,Value&gt;::iterator SplayTree&lt;Key,Value&gt;:: findHelper(Node&lt;Key,Value&gt;* nod,const Key&amp; k)<br>{<br>    if(nod==NULL)<br>    {<br>        typename SplayTree&lt;Key,Value&gt;::iterator end(NULL);<br>        return end;<br>    }<br>    if(nod-&gt;getKey()&lt;k)//k is on the right subtree<br>    {<br>        return findHelper(nod-&gt;getRight(),k);<br>    }else if(nod-&gt;getKey()&gt;k)// k is on the left subtree<br>    {<br>        return findHelper(nod-&gt;getLeft(),k);<br>    }else {<br>        typename SplayTree&lt;Key,Value&gt;::iterator it(nod);<br>        return it;<br>    }<br>}</p><p>#endif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写 数据结构预算法:在老师给的class基础上再完成splayTree,cacheLRU&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++代写大数加减乘除</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000010/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000010/</id>
    <published>2018-09-29T12:58:44.000Z</published>
    <updated>2018-11-04T09:03:18.459Z</updated>
    
    <content type="html"><![CDATA[<p>代写一个大数加减乘除的计算器,通过所有测试<br><a id="more"></a><br>COSC2430: Programming and Data Structures<br>HW2: Evaluate Arithmetic Expressions using stack<br>1<br>Introduction<br>You will create a C++ program that can evaluate arithmetic expressions with integer numbers having any number of<br>digits. These numbers are an alternative to fixed size integers or floating point numbers that always have a maximum<br>number of accurate digits (dependent on size of CPU register).<br>2<br>Input and Output<br>The input is a regular text file, where each line is terminated with an end-of-line character(s). Each line will contain<br>an arithmetic expression. Operators + − ∗ is mandatory. 10% extra credits for operator /. The program should display<br>the input expression and the results, separated with =. You need to check whether the expression is valid or not. If one<br>expression is not valid, skip it and continue to process next expression.<br>Input example:<br>0<em>00000000000000000+0000000000000001<br>(1+2)</em>(1000+2000)<br>(+1+2)<em>(1000+2000)<br>((1+2)</em>(1000+2000))<em>(1+10000)<br>(1+2)</em>(1000+2000))<em>(1+10000)<br>(1000000000000000-1)<br>9999999999999999999999/9999999999999999999999<br>(-100000+10000)</em>8<br>((-1))-(-1)<br>Output example:<br>0<em>00000000000000000+0000000000000001=1<br>(1+2)</em>(1000+2000)=9000<br>(+1+2)<em>(1000+2000)=9000<br>((1+2)</em>(1000+2000))<em>(1+10000)=90009000<br>(1000000000000000-1)=999999999999999<br>9999999999999999999999/9999999999999999999999=1<br>(-100000+10000)</em>8=-720000<br>((-1))-(-1)=0<br>3<br>Program input and output specification<br>The main program should be called infinitearithmetic. Call syntax at the OS prompt:<br>infinitearithmetic input=input1.txt<br>Assumptions:<br>• The file is a small plain text file (say &lt; 10000 expressions); no need to handle binary files.• Only integer numbers as input (no decimals!). Input numbers may have leading zeroes. Output number will be<br>written without leading zeroes (i.e. eliminate them).<br>• Operators: + − ∗/. 10% extra credits for operator /.<br>• Keep in mind a single + or can be a sign instead of an operator.<br>• You can assume the input are only integers and the ouptut is only an integer. Therefore, you can truncate the<br>decimal part when evaluating division.<br>• do not break an arithmetic expression into multiple lines as it will mess testing.<br>4<br>Requirements<br>• Homework is individual. Your homework will be automatically screened for code plagiarism against code from<br>the other students and code from external sources. If you copy/download source code from the Internet or a<br>book it is better you acknowledge it in your comments, instead of the TAs detecting it. Code that is detected<br>to be copied from another student (for instance, renaming variables, changing for and while loops, changing<br>indentation, etc) will result in ”Fail” in the course and being reported to UH upper administration.<br>• std::stack is not allowed. Please implement your own stack.<br>• Remove leading zeroes from the result (e.g. 1, instead of 00001; 0 instead of 00000).<br>• timeout is set to 10s.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代写一个大数加减乘除的计算器,通过所有测试&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转二叉树 rotateBST</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000009/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000009/</id>
    <published>2018-09-29T12:54:09.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写<br><a id="more"></a></p><p>#ifndef rotateBST_H_</p><p>#define rotateBST_H</p><p>#include <vector></vector></p><p>#include “bst.h”<br>using namespace std;</p><p>template <typename key,typename="" value=""><br>class BinarySearchTree;</typename></p><p>template <typename key,typename="" value=""><br>class rotateBST:public BinarySearchTree&lt;Key,Value&gt;</typename></p><p>{<br>    public:<br>        int sameKeys(const rotateBST&lt;Key,Value&gt;&amp; t2) const;//if this have all the same keys with t2<br>        void transform(rotateBST&lt;Key,Value&gt;&amp; t2)const ;<br>    protected:<br>        void leftRotate(Node&lt;Key,Value&gt;<em> r);<br>        void rightRotate(Node&lt;Key,Value&gt;</em> r);<br>    private:<br>        void recurHelper(Node&lt;Key,Value&gt;<em> nod1,Node&lt;Key,Value&gt;</em> nod2,rotateBST&lt;Key,Value&gt;&amp; t2) const;//we make left child .right of nd2 ok<br>        int UpdateHeight(Node&lt;Key,Value&gt;* nod);</p><p>};</p><p>template <typename key,typename="" value=""><br>int rotateBST&lt;Key,Value&gt;::sameKeys(const rotateBST&lt;Key,Value&gt;&amp; t2) const<br>{<br>    typename rotateBST&lt;Key,Value&gt;::iterator it1(this-&gt;getSmallestNode());<br>    typename rotateBST&lt;Key,Value&gt;::iterator end1(NULL);<br>    typename rotateBST&lt;Key,Value&gt;::iterator it2(t2.getSmallestNode());<br>    typename rotateBST&lt;Key,Value&gt;::iterator end2(NULL);<br>    while(it1!=end1&amp;&amp;it2!=end2)<br>    {<br>        if((<em>it1).first!=(</em>it2).first)<br>        {<br>            return false;<br>        }<br>        ++it1;<br>        ++it2;<br>    }<br>    if(it1!=end1||it2!=end2)<br>    {<br>        return false;<br>    }</typename></p><pre><code>return true;</code></pre><p>}</p><p>template <typename key,typename="" value=""><br>void rotateBST&lt;Key,Value&gt;::transform(rotateBST&lt;Key,Value&gt;&amp; t2) const<br>{<br>    if(sameKeys(t2)==false)<br>    {<br>        return;<br>    }</typename></p><pre><code>recurHelper(NULL,NULL,t2);</code></pre><p>}</p><p>template <typename key,typename="" value=""><br>void rotateBST&lt;Key,Value&gt;::recurHelper(Node&lt;Key,Value&gt;<em> nod1,Node&lt;Key,Value&gt;</em> nod2,rotateBST&lt;Key,Value&gt;&amp; t2) const//we make left child .right of nd2 ok<br>{<br>    if(nod1==NULL&amp;&amp;nod2==NULL)<br>    {<br>        while(t2.mRoot-&gt;getLeft()!=NULL)<br>        {<br>            t2.rightRotate(t2.mRoot);</typename></p><pre><code>    }    auto p=t2.mRoot;    while(p-&gt;getRight()!=NULL)    {        while(p-&gt;getRight()-&gt;getLeft()!=NULL)        {            t2.rightRotate(p-&gt;getRight());        }        p=p-&gt;getRight();    }    while(this-&gt;mRoot-&gt;getKey()!=t2.mRoot-&gt;getKey())    {        t2.leftRotate(t2.mRoot);    }    recurHelper(this-&gt;mRoot,t2.mRoot,t2);}else{    if(nod2-&gt;getLeft()!=NULL)    {        //make the left of nod2 linked list        while(nod2-&gt;getLeft()-&gt;getLeft()!=NULL)        {            t2.rightRotate(nod2-&gt;getLeft());        }        auto nod=nod2-&gt;getLeft();        while(nod-&gt;getRight()!=NULL)        {            while(nod-&gt;getRight()-&gt;getLeft()!=NULL)            {                t2.rightRotate(nod-&gt;getRight());            }            nod=nod-&gt;getRight();        }        //make key same        while(nod2-&gt;getLeft()-&gt;getKey()!=nod1-&gt;getLeft()-&gt;getKey())        {            t2.leftRotate(nod2-&gt;getLeft());        }        recurHelper(nod1-&gt;getLeft(),nod2-&gt;getLeft(),t2);    }    if(nod2-&gt;getRight()!=NULL)    {        //make the left of nod2 linked list        while(nod2-&gt;getRight()-&gt;getLeft()!=NULL)        {            t2.rightRotate(nod2-&gt;getRight());        }        auto nod=nod2-&gt;getRight();        while(nod-&gt;getRight()!=NULL)        {            while(nod-&gt;getRight()-&gt;getLeft()!=NULL)            {                t2.rightRotate(nod-&gt;getRight());            }            nod=nod-&gt;getRight();        }        //make key same        while(nod2-&gt;getRight()-&gt;getKey()!=nod1-&gt;getRight()-&gt;getKey())        {            t2.leftRotate(nod2-&gt;getRight());        }        recurHelper(nod1-&gt;getRight(),nod2-&gt;getRight(),t2);    }    nod2-&gt;setHeight(nod1-&gt;getHeight());}</code></pre><p>}</p><pre><code>template &lt;typename Key,typename Value&gt;</code></pre><p>void rotateBST&lt;Key,Value&gt;::leftRotate(Node&lt;Key,Value&gt;<em> r)<br>{<br>    if(r==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> z=r;<br>    Node&lt;Key,Value&gt;<em> y=r-&gt;getRight();<br>    if(y==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> t2=y-&gt;getLeft();<br>    Node&lt;Key,Value&gt;* p=z-&gt;getParent();<br>    //ok</p><pre><code>//parentif(p==NULL) this-&gt;mRoot=y;else if(p-&gt;getLeft()==z) p-&gt;setLeft(y);else if(p-&gt;getRight()==z) p-&gt;setRight(y);//zz-&gt;setRight(t2);z-&gt;setParent(y);//yy-&gt;setParent(p);y-&gt;setLeft(z);//t2if(t2!=NULL)    t2-&gt;setParent(z);//deal z heightif(z-&gt;getLeft()==NULL&amp;&amp;t2==NULL){    z-&gt;setHeight(1);}else if(z-&gt;getLeft()==NULL){    z-&gt;setHeight(t2-&gt;getHeight()+1);}else if(t2==NULL){    z-&gt;setHeight(z-&gt;getLeft()-&gt;getHeight()+1);}else{    z-&gt;setHeight(max(z-&gt;getLeft()-&gt;getHeight(),t2-&gt;getHeight())+1);}if(y-&gt;getRight()!=NULL){    y-&gt;setHeight(max(y-&gt;getRight()-&gt;getHeight(),z-&gt;getHeight())+1);}else{    y-&gt;setHeight(z-&gt;getHeight()+1);}if(p!=NULL){    if(p-&gt;getLeft()!=NULL&amp;&amp;p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(max( p-&gt;getLeft()-&gt;getHeight(),p-&gt;getRight()-&gt;getHeight()  )+1);    }else if(p-&gt;getLeft()!=NULL)    {        p-&gt;setHeight(p-&gt;getLeft()-&gt;getHeight()+1);    }else if(p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(p-&gt;getRight()-&gt;getHeight()+1);    }else    {        p-&gt;setHeight(1);    }}return ;</code></pre><p>}</p><pre><code>template &lt;typename Key,typename Value&gt;</code></pre><p>void rotateBST&lt;Key,Value&gt;::rightRotate(Node&lt;Key,Value&gt;<em> r)<br>{<br>    if(r==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> z=r;<br>    Node&lt;Key,Value&gt;<em> y=z-&gt;getLeft();<br>    if(y==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> t3=y-&gt;getRight();<br>    Node&lt;Key,Value&gt;* p=z-&gt;getParent();<br>    //ok</p><pre><code>//parentif(p==NULL) this-&gt;mRoot=y;else if(p-&gt;getLeft()==z) p-&gt;setLeft(y);else if(p-&gt;getRight()==z) p-&gt;setRight(y);//zz-&gt;setLeft(t3);z-&gt;setParent(y);//yy-&gt;setParent(p);y-&gt;setRight(z);//t3if(t3!=NULL)    t3-&gt;setParent(z);//deal z heightif(z-&gt;getRight()==NULL&amp;&amp;t3==NULL){    z-&gt;setHeight(1);}else if(z-&gt;getRight()==NULL){    z-&gt;setHeight(t3-&gt;getHeight()+1);}else if(t3==NULL){    z-&gt;setHeight(z-&gt;getRight()-&gt;getHeight()+1);}else{    z-&gt;setHeight(max(z-&gt;getLeft()-&gt;getHeight(),z-&gt;getRight()-&gt;getHeight())+1);}if(y-&gt;getLeft()!=NULL){    y-&gt;setHeight(max(y-&gt;getLeft()-&gt;getHeight(),z-&gt;getHeight())+1);}else{    y-&gt;setHeight(z-&gt;getHeight()+1);}if(p!=NULL){    if(p-&gt;getLeft()!=NULL&amp;&amp;p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(max( p-&gt;getLeft()-&gt;getHeight(),p-&gt;getRight()-&gt;getHeight()  )+1);    }else if(p-&gt;getLeft()!=NULL)    {        p-&gt;setHeight(p-&gt;getLeft()-&gt;getHeight()+1);    }else if(p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(p-&gt;getRight()-&gt;getHeight()+1);    }else    {        p-&gt;setHeight(1);    }}return ;</code></pre><p>}</p><p>#endif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="c/c_++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>cs作业代写 哈弗曼树</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000008/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000008/</id>
    <published>2018-09-29T12:50:25.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>Final Project: Huffman Encoding<br><a id="more"></a><br>Assigned: April 27, 2018</p><p>Due: May 15, 2018 at 5pm<br>Summary: In this assignment, you will apply several of the data structures we have used<br>in class to create a file compression/decompression system using the Huffman<br>Encoding algorithm. You will have some time in class to work on the<br>assignment with your partner, but plan to spend time outside of class on the<br>assignment as well.<br>Learning To experience full-system object oriented design and appropriately use<br>Goals: provided data structures.<br>Collaboration: For this assignment, you will submit work in partners assigned in class. While<br>you can work with your partner any way you wish, I encourage you to use a<br>pair-programming approach while working on Class 1 in particular, whereas<br>Classes 2 and 3 can be worked on independently.<br>Submission : Turnin Form<br>Assignment<br>In this assignment, you will be working on information compression using a Huffman Tree. It is a<br>large assignment, so start with your partner early. You can choose to either work on it in a pair-<br>programming approach or by dividing some of the interfaces described below, implementing them<br>independently, and integrating them. While test-driven development for individual classes is<br>recommended, submission of test cases is not required. Bare-bones starter code is provided here.<br>At this point, you should be familiar with the core standard library data structures such as strings,<br>   vectors, lists, stacks, queues, sets, and maps. Use them judiciously in your assignment!<br>   Additionally, you are provided with utility classes for bitstreams, objects that work like regular<br>   streams but read and write individual bits instead of multi-bit or multi-character data elements.<br>   Note that while the interfaces below are required, you may also write additional internal methods if<br>   it helps you organize your code. Do make sure that different classes and declared in different<br>   header files, implemented in different implementation files, and added to the Makefile for<br>   compilation.<br>   Class 1: The decision tree (40%)<br>   In a prior assignment, you implemented a special-purpose decision tree where internal and<br>   external nodes each held different kinds of information. In this assignment, you will create a new<br>   decision tree class that stores different information. The Huffman decision tree is a binary tree<br>   where every node has a “weight” property describing the cumulative frequencies of everything in<br>   that subtree, and leaves additionally have a “value” property that describes the character<br>   represented by that leaf. A description of the Huffman tree construction algorithm is in section 12.4<br>   of our textbook. You are strongly encouraged to review the previous decision tree assignment to<br>   make this component easier.<br>   The Huffman tree class should implement the following interfaces:<br>       <a href="http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml" target="_blank" rel="noopener">http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml</a><br>       1/35/5/2018<br>       CS 270, 2018S: Final Project<br>       HuffmanTree(const map&lt;char, float&gt;&amp;): construct a Huffman Tree from a set of characters<br>                                             with frequencies. Your constructor should use the algorithms from the textbook and in class<br>                                             to build a tree by merging subtrees together. Remember, a priority queue of Nodes is going<br>                                             to be very helpful here!<br>                                             void writeTree(ostream&amp;): write the Huffman tree as text to a stream. The encoding format<br>                                                                       for the Huffman decision tree is similar to the question-based decision tree. Print one node<br>                                                                       per line: if the node is an internal node, begin the line with “NODE:”, followed by the<br>                                                                       frequency of the characters in that subtree. If a node is a leaf, begin the line with “LEAF:”,<br>                                                                       followed by the character, followed by the frequency of that character. A simple tree might<br>                                                                       look like:<br>                                                                       NODE: 1.0<br>                                                                       LEAF: a 0.5<br>                                                                       LEAF: b 0.5<br>                                                                       HuffmanTree(istream&amp;): construct a Huffman Tree from an already-open stream, according to<br>    the same tree format described above. When done, the constructor should use the seekg<br>                                                                                         method to reset the istream to the beginning of its content (like closing and reopening the file,<br>                                                                                                 without actually closing and reopening it.)<br>                                                                                              char decode(ibitstream&amp;): beginning at the top of Huffman tree, decode a single character<br>                                                                                                                        from a stream of bits. Use the ibitstream member function “readBit” to read individual bits.<br>                                                                                                                        Traverse the tree, and return the decoded character. You may want to revisit the traversal<br>                                                                                                                        code of the previous Decision Tree data structure as a refresher.<br>                                                                                                                        map&lt;char, std::vector<int>&gt; getEncodings(): Traverse the Huffman tree internally to construct<br>                                                                                                                                                                    a map from each character represented in the Huffman Tree to the bit coding that would be<br>                                                                                                                                                                    required to reach that character in the tree. (Hint: think about using a vector as a stack.<br>                                                                                                                                                                            Keep track of what choices you have made in your traversal by pushing items on to the back<br>                                                                                                                                                                            of the vector, and when you reach a leaf, the vector will contain the sequence of choices<br>                                                                                                                                                                            made to reach that leaf. Add that vector to the map, and when you return from a recursion<br>                                                                                                                                                                            step in the traversal, pop the last decision-item off the end of the stack. All of the entries in<br>                                                                                                                                                                            the vector should be either 0 or 1.)<br>                                                                                                                                                                    To test your HuffmanTree separately from an encoder, decoder, you’ll have to manually construct<br>                                                                                                                                                                    the map and stream arguments in your test cases. Recall that cout can be used as an ostream,<br>                                                                                                                                                                    cin as an istream. Bitstreams are a little different: take a look at the ibitstreamtest.cpp file to see<br>                                                                                                                                                                    an example of how to create and use stringbitstream objects that might help you in your test cases.<br>                                                                                                                                                                    Class 2: The Huffman Encoder (25%)<br>                                                                                                                                                                    This class will have a HuffmanTree and an istream&amp; as fields, and will use it to manage the<br>                                                                                                                                                                    encoding and decoding of files through the following interfaces<br>                                                                                                                                                                    HuffmanEncoder(istream&amp;): create an encoder and construct the HuffmanTree for the given<br>                                                                                                                                                                                              istream. When the construction is completed, reset the istream to the beginning of its input<br>                                                                                                                                                                                              using the seekg function with the std::ios::beg position marker, e.g.<br>                                                                                                                                                                                              “mystream.seekg(0,std::ios::beg);”<br>                                                                                                                                                                                              int writeEncodedText(obitstream&amp;): write the original text in encoded format to the given,<br>                                                                                                                                                                                              open obitstream, and return the number of characters encoded. Remember to reset the<br>                                                                                                                                                                                                                                 istream position at the end of the function.<br>                                                                                                                                                                                                                                 void writeTree(ostream&amp;): invokes the writeTree function of the HuffmanTree to write the tree<br>                                                                                                                                                                                                                                                           used to encode this istream to the given output stream.<br>                                                                                                                                                                                                                                                           Class 3: The Huffman Decoder (25%)<br>                                                                                                                                                                                                                                                           <a href="http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml" target="_blank" rel="noopener">http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml</a><br>                                                                                                                                                                                                                                                               2/35/5/2018<br>                                                                                                                                                                                                                                                               CS 270, 2018S: Final Project<br>                                                                                                                                                                                                                                                               This class will have a HuffmanTree as a field, and will use it to manage the decoding of a<br>                                                                                                                                                                                                                                                               compressed stream as produced by the encoder.<br>                                                                                                                                                                                                                                                               HuffmanDecoder(istream&amp;): create a decoder and construct the HuffmanTree from the given<br>                                                                                                                                                                                                                                                                                         istream, which stores the tree in text format (as produced by writeTree).<br>                                                                                                                                                                                                                                                                                         void decodeText(int, ibitstream&amp;, ostream&amp;): decode the message from the given input bit<br>                                                                                                                                                                                                                                                                                                                                      stream into the output character stream. The first argument indicates the expected number<br>                                                                                                                                                                                                                                                                                                                                      of characters to be decoded.<br>    void writeTree(ostream&amp;): invokes the writeTree function of the HuffmanTree to write the<br>                              tree. (This is primarily for debugging purposes, most applications will not need it.)<br>                              Above and Beyond: User application (10%)<br>                                                To complete the assignment, you must design and write some command-line user interface to<br>                                                enable a user to encode and decode text with the classes you have built. As some suggestions to<br>                                                get you started thinking, you could asking the user to provide names for files to read and write<br>                                                through prompts or the command-line, or asking the user to type strings and print the huffman-<br>                                                encoded results as ‘1’ and ‘0’ characters to the terminal, or write multiple different applications with<br>                                                different main functions for handling encoding and decoding using the same libraries. Whichever<br>                                                route you choose, start by looking up the documentation for the kind of streams you want to deal<br>                                                with - files are handled through ofstreams and ifstreams (or ofbitstreams and ifbitstreams) and<br>                                                strings can be processed using stringstream objects. Good links for the Stanford bitstream<br>                                                libraries here, and the C++ standard i/o library here. Talk with your partner to decide how you want<br>                                                your application to be informative, artistic, utilitarian, fun, or any or all of the above. Whatever<br>                                                interface you design and choose, include a README.txt file that describes what you did and how<br>                                                to use your application.<br>                                                Submitting your work<br>                                                Make sure your files are named correctly as specified above. In your comments at the top, make<br>                                                sure you:<br>                                                acknowledge any help or outside sources, in accordance with the academic honesty policy;<br>                                                describe any known bugs in the program.<br>                                                Rezip your materials using the command “zip -r mywhitmanID_Huffman.zip FP_huffman” in the<br>                                                folder containing the final project unzipped package. Submit your completed package using the<br>                                                online turnin form. Be sure to select the Final Project.</int></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Final Project: Huffman Encoding&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写 cs代写 Book Ciper</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000007/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000007/</id>
    <published>2018-09-29T12:40:24.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写 cs代写 Book Ciper<br><a id="more"></a></p><h1 id="Project-2-–-Book-Cipher"><a href="#Project-2-–-Book-Cipher" class="headerlink" title="Project #2 – Book Cipher"></a>Project #2 – Book Cipher</h1><p>Course<br>Professor<br>Assigned<br>Due<br>Weight<br>Student Name<br>INFO-1156 Object-Oriented Programming in C++<br>Garth Santor, Lianne Wong, and Janice Manning<br>March 19 th 2018<br>April 6 th 2018 @ 11:59pm<br>5%<br>Project Description<br>Create two C++ console applications; one that encodes a text message using a book<br>cipher, and another that decodes the message coded by the previous program.<br>Program Interfaces<br>The encoder should have the following command-line interface:<br>bcencode.exe bookfile messagefile codedfile<br>The decoder should have the following command-line interface:<br>bcdecode.exe bookfile codedfile messagefile<br>Where:<br>• bookfile is the name of the ASCII text file containing the book used to<br>encode/decode the message.<br>• messagefile is the name of the ASCII text file containing the message to be<br>encoded<br>• codedfile is the name of the ASCII text file containing the offset numbers<br>Encoding rules<br>Encode each character of the source file by replacing it with two numbers, the first<br>representing the line in the book (zero-based), and the second the offset to that character<br>in that line (also zero-based). Any method of choosing which offset to use is acceptable<br>so long as the same offset isn’t used repeatedly.<br>At the end of running bcencoder, a codedfile is created with offsets.<br>At the end of running bcdecoder, a messagefile is created with the message.<br>The encoded file must be just a file of the exact offsets of the message file.<br>bookfile: “ABCDEFGHIJKLM\nNOPQRSTUVWXYZ”<br>messagefile: “ACER”<br>codedfile: 0x00000000 0x00000000 0x00000000 0x00000002 0x00000000 0x00000004<br>0x00000001 0x00000004<br>Encoding background<br>To read more about encoding messages using the book cipher see:<br><a href="https://en.wikipedia.org/wiki/Book_cipher" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Book_cipher</a><br>In this program, you are encoding letters, not the words. The encoded file will store the<br>number in binary.<br>bctest.exe<br>‘bctest.exe’ is a program that can perform some tests on your encoder and decoder<br>programs. The test program should be placed into the same folder as your executable<br>files. If your programs are properly called ‘bcencode.exe’ and ‘bcdecode.exe’ the test<br>program will automatically execute your programs at appropriate times during the test.<br>Grading Criteria<br>Functional Requirements<br>Encoder works<br>Decoder works<br>Both programs report errors if any of the input files<br>cannot be opened (indicating which file was the<br>problem).<br>The encoder program reports and quits if the message<br>cannot be encoded by the book file (i.e. A character in<br>the message to be encoded does not exist in the book<br>file), and reports which character cannot be encoded.<br>40%<br>40%<br>10% 40%<br>40%<br>10%<br>10% 10%<br>Non-functional requirements<br>Executables program are not named ‘bcencode.exe’ and<br>‘bcdecode.exe’<br>Coded message uses the same index repeatedly for the<br>same letter.<br>Penalties from C &amp; C++ Grading Guide v1.1.0<br>A guide to code/comment style can be found at C++ Style<br>Late submission<br>• One to five days late<br>• More than five days late<br>Total<br>-10% / each<br>-20%<br>Various<br>-10%/day<br>-100%<br>100% 100%<br>Submission</p><ol><li>Submit entire Visual Studio project directory to Fanshawe Online<br>a. Delete all debug and release directories. i<br>b. Submit in a .ZIP, .7z archive file.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写 cs代写 Book Ciper&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写模拟数据库</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000006/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000006/</id>
    <published>2018-09-29T12:37:48.000Z</published>
    <updated>2018-11-04T09:03:09.771Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写:使用hash快速模拟数据库的收发和对应关系<br><a id="more"></a></p><h1 id="COSC2430-Programming-and-Data-Structures"><a href="#COSC2430-Programming-and-Data-Structures" class="headerlink" title="COSC2430: Programming and Data Structures"></a>COSC2430: Programming and Data Structures</h1><h1 id="HW3-Database-System"><a href="#HW3-Database-System" class="headerlink" title="HW3: Database System"></a>HW3: Database System</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>You will write a C++ program to simulate database operation (add, get and delete).</p><h2 id="2-Input-and-Output-Specification"><a href="#2-Input-and-Output-Specification" class="headerlink" title="2 Input and Output Specification"></a>2 Input and Output Specification</h2><p>The records input file is very clean (but may contain duplicated records) and have uniform attributes(columns). Each<br>record stream begins with operation add, delete or get, then follows by a space and a record. For add operation, you<br>will need to add a record with full attributes. However, when you do delete or get operation, you may only have partial<br>attributes. For get operation, you need to output the result in the origin record order and an empty line.<br>Example of input files (between the lines)</p><h2 id="input1-txt"><a href="#input1-txt" class="headerlink" title="input1.txt"></a>input1.txt</h2><p>add {id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}<br>add {id:1234568,first:Peter,last:White,DOB:1997-05-22,GPA:3.8}<br>add {id:1654238,first:Nick,last:Park,DOB:1995-08-18,GPA:4.0}<br>add {id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}<br>get {GPA:4.0}<br>delete {first:Mary}<br>add {id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}</p><h2 id="get-last-Green-GPA-4-0"><a href="#get-last-Green-GPA-4-0" class="headerlink" title="get {last:Green,GPA:4.0}"></a>get {last:Green,GPA:4.0}</h2><h2 id="output1-txt"><a href="#output1-txt" class="headerlink" title="output1.txt"></a>output1.txt</h2><p>{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}<br>{id:1654238,first:Nick,last:Park,DOB:1995-08-18,GPA:4.0}<br>{id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}<br>{id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}</p><h2 id="id-1234567-first-Mary-last-Green-DOB-1996-10-03-GPA-4-0"><a href="#id-1234567-first-Mary-last-Green-DOB-1996-10-03-GPA-4-0" class="headerlink" title="{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}"></a>{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}</h2><h2 id="3-Program-specification"><a href="#3-Program-specification" class="headerlink" title="3 Program specification"></a>3 Program specification</h2><p>The main program should be called ”database”. Call syntax is as follows (from the OS prompt):<br>./database input=input1.txt output=output1.txt<br>Notice that the file name will not necessarily be the same every time. Therefore, your program will have to take that<br>into account.</p><h2 id="4-Requirements"><a href="#4-Requirements" class="headerlink" title="4 Requirements"></a>4 Requirements</h2><p>• Homework is individual. Your homework will be automatically screened for code plagiarism against code from<br>the other students and code from external sources. If you copy/download source code from the Internet or a<br>book it is better you acknowledge it in your comments, instead of the TAs detecting it. Code that is detected<br>to be copied from another student (for instance, renaming variables, changing for and while loops, changing<br>indentation, etc) will result in ”Fail” in the course and being reported to UH upper administration.<br>• The maximum number of records is 100,000. Timeout is set to 2s. That said, your program must get the result<br>file in 2 seconds.<br>• For each operation add, get and delete, you need to do it in O(max(k, n)) time complexity at maximum,<br>where n is current number of records in the database, k is the number of attributes in one record. Failing<br>to do this is likely to get a timeout error. That said, hash table and binary search tree are preferred. Any<br>data structures and algorithms in stl library are allowed.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写:使用hash快速模拟数据库的收发和对应关系&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c_++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Database" scheme="http://holydudecs.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>java代写韩国算法数据结构</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000005/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000005/</id>
    <published>2018-09-29T12:34:29.000Z</published>
    <updated>2018-11-04T09:03:05.435Z</updated>
    
    <content type="html"><![CDATA[<p>比较少见的韩语ppt,代写树的一类算法<br><a id="more"></a></p><p>자료 구조<br>숙제 #05<br>트리<br>2분반 마감 시간: 5월 3일 오후 11시 59분<br>1분반 마감 시간: 5월 6일 오후 11시 59분<br>2018/04/27<br>컴퓨터과학과<br>민경하<br>문제<br>• 다음과 같은 트리가 다음과 같은 형식으로 test.txt 파일<br>에 저장되어 있다.<br>문제<br>• 트리에 대한 자료 구조가 다음과 같이 정의되어 있다.<br>문제<br>• 위의 test.txt 파일로부터 한줄씩 트리에 대한 정보를 읽어들여<br>서 트리에 추가하는 과정을 통해서 트리를 완성한다.<br>문제<br>• 위의 test.txt 파일로부터 한줄씩 트리에 대한 정보를 읽어들여<br>서 트리에 추가하는 과정을 통해서 트리를 완성한다.<br>문제<br>• 위의 트리에 대해서 다음의 3 가지 연산을 구현할 것.<br>• degree (  ): 트리의 degree를 출력하시오.<br>• depth (  ): 트리의 depth를 출력하시오.<br>• width (  ): 트리의 width를 출력하시오.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较少见的韩语ppt,代写树的一类算法&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写简单的c++作业</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000004/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000004/</id>
    <published>2018-09-29T06:40:24.000Z</published>
    <updated>2018-11-04T09:03:28.919Z</updated>
    
    <content type="html"><![CDATA[<p>代写一个查询系统,对数据进行快速读入,随后对数据进行查询.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct Data&#123;</span><br><span class="line">    char source[20];</span><br><span class="line">    char name[10];</span><br><span class="line">    int color;//色度</span><br><span class="line">    float ph;//ph 值</span><br><span class="line">    int Ga;//gai钙</span><br><span class="line">    int Mg;//镁</span><br><span class="line">    int Na;//钠</span><br><span class="line">    float radio;//放射性</span><br><span class="line">    struct Data* next;</span><br><span class="line">&#125;;//用链表</span><br><span class="line">//同时我们会做一个fake head</span><br><span class="line"></span><br><span class="line">struct Data* head ;</span><br><span class="line">/*struct Data* head = (struct Data*) malloc(sizeof(struct Data));*/</span><br><span class="line"></span><br><span class="line">struct Data* NewDataNode()</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* node=(struct Data*) malloc(sizeof(struct Data));</span><br><span class="line">    for(int i=0;i&lt;20;i++) node-&gt;source[i]=0;</span><br><span class="line">    for(int i=0;i&lt;10;i++) node-&gt;name[i]=0;</span><br><span class="line">    node-&gt;color=-1;</span><br><span class="line">    node-&gt;ph=-1;</span><br><span class="line">    node-&gt;Ga=-1;</span><br><span class="line">    node-&gt;Mg=-1;</span><br><span class="line">    node-&gt;Na=-1;</span><br><span class="line">    node-&gt;radio=-1;</span><br><span class="line">    node-&gt;next=NULL;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputData(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stdout,&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);</span><br><span class="line">    /*fprintf(stdout,&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);*/</span><br><span class="line">    /*printf(&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int After(struct Data* l,struct Data * r)//l be after r?</span><br><span class="line">&#123;</span><br><span class="line">    if(l-&gt;radio&gt;r-&gt;radio) return 1;</span><br><span class="line">    if(l-&gt;radio&lt;r-&gt;radio) return 0;</span><br><span class="line">    if(l-&gt;Mg&lt;r-&gt;Mg) return 1;</span><br><span class="line">    if(l-&gt;Mg&gt;r-&gt;Mg) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertNode(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* tmp=head;</span><br><span class="line">    while(tmp-&gt;next&amp;&amp;After(node,tmp-&gt;next))</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct Data* next=tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next=node;</span><br><span class="line">    node-&gt;next=next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ValidString(char ch)</span><br><span class="line">&#123;</span><br><span class="line">    if(ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) return 1;</span><br><span class="line">    if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;) return 1;</span><br><span class="line">    if(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) return 1;</span><br><span class="line">    if(ch==13||ch==10) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eof=0;</span><br><span class="line"></span><br><span class="line">struct Data* ReadData(FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* node=NewDataNode();</span><br><span class="line"></span><br><span class="line">    char ch;</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;20&amp;&amp;(ch=fgetc(fp))!=&apos;,&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ch==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            free(node);</span><br><span class="line">            eof=1;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!ValidString(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">            free(node);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        /*printf(&quot;%dth ch:%d\n&quot;,i,ch);*/</span><br><span class="line">        if(ch!=&apos;\n&apos;&amp;&amp;ch!=13&amp;&amp;ch!=10)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;source[i]=ch;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==20||i==0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    /*printf(&quot;1\n&quot;);*/</span><br><span class="line"></span><br><span class="line">    i=0;</span><br><span class="line">    while(i&lt;10&amp;&amp;(ch=fgetc(fp))!=&apos;,&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;name[i]=ch;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==0||i==10)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        /*printf(&quot;\n2\n&quot;);*/</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rd=fscanf(fp,&quot;%d,%f,%d,%d,%d,%f&quot;,&amp;node-&gt;color,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na,&amp;node-&gt;radio);</span><br><span class="line">    if(rd!=6)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        /*printf(&quot;\n3\n&quot;);*/</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InsertNode(node);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Better(struct Data* l, struct Data* r)//l&apos;s color ,ph ,Ga , Na, Mg should be less that r</span><br><span class="line">&#123;</span><br><span class="line">    if(l-&gt;color&gt;r-&gt;color) return 0;</span><br><span class="line">    if(l-&gt;Ga&gt;r-&gt;Ga) return 0;</span><br><span class="line">    if(l-&gt;Na&gt;r-&gt;Na) return 0;</span><br><span class="line">    if(l-&gt;Mg&gt;r-&gt;Mg) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BetterOutput(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* tmp=head-&gt;next;</span><br><span class="line">    while(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Better(tmp,node))</span><br><span class="line">        &#123;</span><br><span class="line">            OutputData(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    head = (struct Data*) malloc(sizeof(struct Data));</span><br><span class="line">    FILE *fp=NULL;//打开文件</span><br><span class="line">    fp=fopen(&quot;samples.txt&quot;,&quot;r&quot;);</span><br><span class="line">    if(fp==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;File open error!\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //下面开始读取文件并存储到链表中</span><br><span class="line"></span><br><span class="line">    struct Data* tmp=head-&gt;next;</span><br><span class="line">    while(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        if(ReadData(fp)==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if(eof==1)//read the End Of File</span><br><span class="line">            &#123;</span><br><span class="line">                eof=0;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                /*GG*/</span><br><span class="line">                tmp=head;</span><br><span class="line">                while(tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    struct Data* next=tmp-&gt;next;</span><br><span class="line">                    free(tmp);</span><br><span class="line">                    tmp=next;</span><br><span class="line">                &#125;</span><br><span class="line">                fclose(fp);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*tmp=head-&gt;next;*/</span><br><span class="line">    /*while(tmp)*/</span><br><span class="line">    /*&#123;*/</span><br><span class="line">    /*Data* next=tmp-&gt;next;*/</span><br><span class="line">    /*OutputData(tmp);*/</span><br><span class="line">    /*tmp=next;*/</span><br><span class="line">    /*&#125;*/</span><br><span class="line"></span><br><span class="line">    //下面这个循环是在进行查询和搜索</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\n\n输入color ph Ga Mg Na的最大值(q开头结束)\n&quot;);</span><br><span class="line">        struct Data* node= NewDataNode();</span><br><span class="line">        char ch=0;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        if(ch==&apos;q&apos;)</span><br><span class="line">            break;</span><br><span class="line">        node-&gt;color=ch-&apos;0&apos;;</span><br><span class="line">        while((ch=getchar())!=&apos; &apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;color=node-&gt;color*10+ch-&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        fscanf(stdin,&quot;%f%d%d%d&quot;,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na);</span><br><span class="line">        /*OutputData(node);*/</span><br><span class="line">        while(getchar()!=&apos;\n&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        /*fscanf(stdin,&quot;%d%f%d%d%d&quot;,&amp;node-&gt;color,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na);*/</span><br><span class="line">        BetterOutput(node);</span><br><span class="line">        free(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //free malloc memory</span><br><span class="line">    tmp=head;</span><br><span class="line">    while(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        struct Data* next=tmp-&gt;next;</span><br><span class="line">        free(tmp);</span><br><span class="line">        tmp=next;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代写一个查询系统,对数据进行快速读入,随后对数据进行查询.&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写 多线程编程</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000003/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000003/</id>
    <published>2018-09-29T06:31:17.000Z</published>
    <updated>2018-11-04T09:02:33.283Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写:多线程编程<br>完成一个多线程变成,c/c++代写<br><a id="more"></a></p><h1 id="CS305-作業系統概論-Homework-2-Multithreading"><a href="#CS305-作業系統概論-Homework-2-Multithreading" class="headerlink" title="CS305 作業系統概論 Homework #2 Multithreading"></a>CS305 作業系統概論 Homework #2 Multithreading</h1><h3 id="2018-04-18"><a href="#2018-04-18" class="headerlink" title="2018.04.18"></a>2018.04.18</h3><h2 id="一、-作業目的"><a href="#一、-作業目的" class="headerlink" title="一、 作業目的"></a>一、 作業目的</h2><p>熟悉如何使用Pthreads的API,撰寫multithreaded program。</p><h2 id="二、-作業內容"><a href="#二、-作業內容" class="headerlink" title="二、 作業內容"></a>二、 作業內容</h2><p>【大數據中的關鍵文件】為了要在許多文件中找出關鍵文件,L公司想要來利用電腦科技來達成目標。<br>對L公司而言,在一個有M個文件的文件集合D={d 1 ,d 2 ,…,d M }中,關鍵文件d k 就是與其他文件的相似度總<br>和最高的文件。但對於如何快速計算文件的相似度,L公司卻毫無頭緒。<br>於是L公司來到風之塔學院尋求幫助。對於這個大數據問題,風之塔學院的C教授帶著他的高徒開發這個<br>程式。C教授決定先使用傑卡德相似係數(Jaccard similarity coefficient)的方法來計算,找出關鍵文件。傑<br>卡德相似係數的公式如下,在兩個集合 A 與 B 中,兩個集合A和B的交集元素個數在A,B的聯集元素個<br>數中所佔的比例,就是它們的傑卡德相似係數:<br>J ( A , B  ) = | A ∩ B |/ | A ∪ B |<br>因此如果對下面兩個文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d 1 = “this is a book”</span><br><span class="line">d 2 = “this is a pen”</span><br><span class="line">J(d 1, d 2 )=3/5=0.6</span><br></pre></td></tr></table></figure></p><p>C教授同時要用multithreaded programming 的方式來設計程式。每一份文件對其他M-1份文件的平均傑卡<br>德相似係數(Average J(d 1, d 2 ))是由一個單獨的thread 來計算出來。所有文件會放在一個檔案中,程式須由<br>命令列讀入檔名。檔案中最多會有50個文件。每個文件會有兩行資料,第一行是文件的ID,第二行是文<br>件內容。文件ID會是一個字串,文件內容中的字詞會由一個或多個空白隔開。傑卡德相似係數如果有多<br>位小數,需要至少精準到小數點後5位。在處理文件時,依照下面規則處理:</p><ol><li>只考慮純字母組成的詞。</li><li>如果有重複出現的詞,只計算一次。例如: “a good book is a book” 中, “book”只算出現一次。<br>在程式執行時,</li><li>主執行緒針對文件數量產生對應的子執行緒。例如有4份文件,就產生4個子執行緒。主執行緒並負<br>責印出來下列事項,印出內容時,每一行需要印出 “[Main thread]”:<br>a. 每一個子執行緒的 tid,以及所負責計算的主文件ID。<br>b. 具有最高平均傑卡德相似係數的文件ID及文件內容。<br>c. 整個程式會用多少CPU時間 (以ms為單位)。</li><li>子執行緒則負責計算傑卡德相似係數。執行過程中,要列印出本身的動作,並且每一行都要印出自<br>己的thread id 。以下是需要印出的項目:<br>a. 負責計算的主文件ID編號。<br>b. 子執行緒計算傑卡德相似係數時,要印出是哪兩個文件在計算,以及它們Jaccard similarity。<br>c. 最後的平均傑卡德相似係數。<br>d. 子執行緒執行會用多少CPU時間 (以ms為單位)。<br>以下是一個可能的執行過程:<blockquote><p>prog2 data.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Main thread]: create TID:123, DocID:0001</span><br><span class="line">[TID=123] DocID:0001</span><br><span class="line">[TID=123] J(0001,0002)=0.6</span><br><span class="line">[TID=123] J(0001,0003)=0.6</span><br><span class="line">...</span><br><span class="line">[TID=123] AvgJ:0.511</span><br><span class="line">[TID=123] CPU time: 20ms</span><br><span class="line">...</span><br><span class="line">[Main thread] KeyDocID:0003 HighestJ:0.9999</span><br><span class="line">[Main thread] CPU time: 2000ms</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="二、-作業要點"><a href="#二、-作業要點" class="headerlink" title="二、 作業要點"></a>二、 作業要點</h2><ol><li>請注意,本作業使用的程式語言是C/C++,測試平台的作業系統: Ubuntu 17.10 LTS 64-bit。使用的<br>編譯程式為gcc/g++ 編譯器:7.2。其他平台或程式語言不在本次作業考慮範圍之內。如在測試平台上<br>無法編譯與執行,都不予給分。</li><li>請注意,本作業一定要用Pthread API來進行。任何不用Pthread API的程式,都不予給分。</li><li>本作業的評分方式如下:<br>a. 每一個項目能正確執行時,最多可得的分數如下<br>i. 從命令列讀入檔名參數,20分。<br>ii. 能產生 pthread,10分。<br>iii. 子執行緒可以印出本身的tid,20分。<br>iv. 傑卡德相似係數計算。不可以使用任何套件或函式庫,需自己完成。20分。<br>v.<br>印出執行所用的CPU時間,20分。<br>vi. 主執行緒找出關鍵文件並印出它的平均傑卡德相似係數,20分。</li><li>本作業需繳交檔案:<br>a. 說明報告:檔案為docx或pdf格式。<br>i. 報告中必須說明程式的設計理念、程式如何編譯,以及如何操作。<br>ii. 報告中同時必須詳細說明你完成哪些部份。如有用到特殊程式庫,請務必說明。<br>iii. 請務必讓助教明白如何編譯及測試你的程式。助教如果無法編譯或測試,會寄信(最多兩<br>次)通知你來說明,但每說明一次,助教會少給你10分。<br>b. 完整原始程式碼檔案。程式碼檔案必須是可直接編譯的檔案。不可含執行檔。助教會重新編譯你<br>們的程式。</li><li>所有相關檔案,例如報告檔、程式檔、參考資料等,請壓縮成一個壓縮檔(不可超過2MB)後上傳<br>至portal。請注意,不可抄襲。助教不會區分何者為原始版本,被判定抄襲者,一律0分。</li><li>如果傑卡德相似係數計算有使用網路範例,務必在作業中說明。該部份將不會計分,但不會判定為<br>抄襲。</li></ol><h2 id="三、-繳交方式"><a href="#三、-繳交方式" class="headerlink" title="三、 繳交方式:"></a>三、 繳交方式:</h2><ol><li>最終繳交時間:<br>a. 電子檔在 2018.05.11 以前,上傳至個人portal。如有多個檔案,將所有檔案壓縮成zip(rar 亦可)格<br>式,然後上傳。<br>b. 上傳檔名格式:「學號<em>作業號碼.docx」或「學號</em>作業號碼.rar」。例如:912233_01.doc 或<br>912233_01.rar。</li><li>如有違規事項者,依照課程規定處理。</li><li>如需請假,請上portal請假,並持相關證明文件,在請假結束後的第一次上課時完成請假手續,並在<br>一週內完成補交。補交作業將以8折計算。</li><li>老師不接受「門縫」方式繳交,助教也不接受任何作業。<h2 id="四、-如有未盡事宜-將在學校portal板面公告通知。"><a href="#四、-如有未盡事宜-將在學校portal板面公告通知。" class="headerlink" title="四、 如有未盡事宜,將在學校portal板面公告通知。"></a>四、 如有未盡事宜,將在學校portal板面公告通知。</h2><h2 id="五、-If-you-need-any-assistance-in-English-please-contact-Prof-Yang"><a href="#五、-If-you-need-any-assistance-in-English-please-contact-Prof-Yang" class="headerlink" title="五、 If you need any assistance in English, please contact Prof. Yang."></a>五、 If you need any assistance in English, please contact Prof. Yang.</h2><h2 id="六、-參考資料"><a href="#六、-參考資料" class="headerlink" title="六、 參考資料"></a>六、 參考資料</h2></li><li>參考課本圖 4.9。</li><li>PThread: <a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">https://computing.llnl.gov/tutorials/pthreads/</a></li><li>POSIX 線 程 (pthread) 入 門 文 章 分 享 : <a href="http://dragonspring.pixnet.net/blog/post/32963482-" target="_blank" rel="noopener">http://dragonspring.pixnet.net/blog/post/32963482-</a><br>posix%E7%B7%9A%E7%A8%8B%28pthread%29%E5%85%A5%E9%96%80%E6%96%87%E7%AB%A<br>0%E5%88%86%E4%BA%AB</li><li>Jaccard index wiki: <a href="https://en.wikipedia.org/wiki/Jaccard_index" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Jaccard_index</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写:多线程编程&lt;br&gt;完成一个多线程变成,c/c++代写&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="多线程编程" scheme="http://holydudecs.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Multithreading" scheme="http://holydudecs.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>c++作业算法实现</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000001/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000001/</id>
    <published>2018-09-29T03:05:27.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写 c++代写<br><a id="more"></a></p><h1 id="CMPSC-360-Discrete-Mathematics-for-Computer-Science"><a href="#CMPSC-360-Discrete-Mathematics-for-Computer-Science" class="headerlink" title="CMPSC 360: Discrete Mathematics for Computer Science"></a>CMPSC 360: Discrete Mathematics for Computer Science</h1><h2 id="Spring-2018-Project-April-3-2018"><a href="#Spring-2018-Project-April-3-2018" class="headerlink" title="Spring 2018 Project April 3, 2018"></a>Spring 2018 Project April 3, 2018</h2><h2 id="Project-Overview"><a href="#Project-Overview" class="headerlink" title="Project Overview"></a>Project Overview</h2><p>You have to implement what you have learned in CMPSC 360 to solve a practical problem of<br>your choice. The goal of the project is to help you in understanding the importance of the<br>concepts you are learning inside the classroom. Since the homework, recitations and other<br>quizzes are limited in scope this project will help you in understanding the practicality of discrete<br>mathematics with an interesting open-ended problem. You will also gain a very important skill of<br>carrying out research and communicating your findings in writing. Plus, it would really look cool<br>on your resume.</p><h2 id="Important-Dates"><a href="#Important-Dates" class="headerlink" title="Important Dates"></a>Important Dates</h2><p>The due date for submitting a proposal 7th April 2018 11:00 pm<br>The due date for submitting final project report and code: 24th April 2018 11:00 pm</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>The main requirement for this project is to demonstrate the ability to demonstrate that you<br>understand the CMPSC 30 concepts and their practical importance.<br>You can work in teams of maximum two students but remember that more the number of people<br>in team more the work should be in the project. We recommend working by yourself.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写 c++代写&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
