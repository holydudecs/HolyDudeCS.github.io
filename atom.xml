<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中国留学生CS作业代写</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://holydudecs.github.io/"/>
  <updated>2018-10-09T12:48:16.426Z</updated>
  <id>http://holydudecs.github.io/</id>
  
  <author>
    <name>Nameless Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS个人代写</title>
    <link href="http://holydudecs.github.io/2045/01/01/Task000000/"/>
    <id>http://holydudecs.github.io/2045/01/01/Task000000/</id>
    <published>2045-01-01T03:05:57.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍:"></a>个人介绍:</h1><p>本人是国内一名程序员</p><ul><li>毕业于<strong>国内CS专业第一高校</strong></li><li>先后在<strong>Baidu,阿里巴巴任职</strong></li><li>熟练掌握各种语言<strong>C/C++,java,python,matlab,Web</strong></li><li>代写范围从<strong>底层汇编到数据算法结构,人工智能,图像游戏,数据库,Android,IOS,Web</strong></li><li>辅导中国留学生CS作业,多年经验,熟知各科得分点</li><li>由于时间有限,本人不做代考与论文写作</li></ul><h1 id="cs作业代写"><a href="#cs作业代写" class="headerlink" title="cs作业代写:"></a>cs作业代写:</h1><h1 id="cs作业代写价格"><a href="#cs作业代写价格" class="headerlink" title="cs作业代写价格:"></a>cs作业代写价格:</h1><table><thead><tr><th>作业种类</th><th>大一</th><th>大二</th><th>大三</th><th>大四</th><th>硕博</th></tr></thead><tbody><tr><td>Lab</td><td>$30-$100</td><td>$75-$150</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Homework</td><td>$40-$150</td><td>$60-$200</td><td>$100-$220</td><td>$200-$280</td><td>$150-$400</td></tr><tr><td>Assignment</td><td>$50-$150</td><td>$80-$200</td><td>$120-$240</td><td>$160-$280</td><td>$150-$400</td></tr><tr><td>Project</td><td>$100-$150</td><td>$140-$200</td><td>$180-$220</td><td>$200-$280</td><td>$150-$400</td></tr><tr><td>Final</td><td>$100-$200</td><td>$140-$200</td><td>$180-$240</td><td>$220-$280</td><td>$150-$400</td></tr></tbody></table><p>请直接给我留言,睡醒之后会马上回复您.请发送给我您的要求,due,相关文件<br>请加微信联系: <img src="images/wechat.jpeg" alt="WeChat"></p><h1 id="作业反馈"><a href="#作业反馈" class="headerlink" title="作业反馈"></a>作业反馈</h1><a id="more"></a><p><img src="images/pic0.jpeg" alt="WeChat"><br><img src="images/pic1.jpeg" alt="WeChat"><br><img src="images/pic2.jpeg" alt="WeChat"><br><img src="images/pic3.jpeg" alt="WeChat"><br><img src="images/pic4.jpeg" alt="WeChat"><br><img src="images/pic5.jpeg" alt="WeChat"><br><img src="images/pic6.jpeg" alt="WeChat"><br><img src="images/pic7.jpeg" alt="WeChat"><br><img src="images/pic8.jpeg" alt="WeChat"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;个人介绍&quot;&gt;&lt;a href=&quot;#个人介绍&quot; class=&quot;headerlink&quot; title=&quot;个人介绍:&quot;&gt;&lt;/a&gt;个人介绍:&lt;/h1&gt;&lt;p&gt;本人是国内一名程序员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;毕业于&lt;strong&gt;国内CS专业第一高校&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;先后在&lt;strong&gt;Baidu,阿里巴巴任职&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;熟练掌握各种语言&lt;strong&gt;C/C++,java,python,matlab,Web&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;代写范围从&lt;strong&gt;底层汇编到数据算法结构,人工智能,图像游戏,数据库,Android,IOS,Web&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;辅导中国留学生CS作业,多年经验,熟知各科得分点&lt;/li&gt;
&lt;li&gt;由于时间有限,本人不做代考与论文写作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;cs作业代写&quot;&gt;&lt;a href=&quot;#cs作业代写&quot; class=&quot;headerlink&quot; title=&quot;cs作业代写:&quot;&gt;&lt;/a&gt;cs作业代写:&lt;/h1&gt;&lt;h1 id=&quot;cs作业代写价格&quot;&gt;&lt;a href=&quot;#cs作业代写价格&quot; class=&quot;headerlink&quot; title=&quot;cs作业代写价格:&quot;&gt;&lt;/a&gt;cs作业代写价格:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作业种类&lt;/th&gt;
&lt;th&gt;大一&lt;/th&gt;
&lt;th&gt;大二&lt;/th&gt;
&lt;th&gt;大三&lt;/th&gt;
&lt;th&gt;大四&lt;/th&gt;
&lt;th&gt;硕博&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Lab&lt;/td&gt;
&lt;td&gt;$30-$100&lt;/td&gt;
&lt;td&gt;$75-$150&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Homework&lt;/td&gt;
&lt;td&gt;$40-$150&lt;/td&gt;
&lt;td&gt;$60-$200&lt;/td&gt;
&lt;td&gt;$100-$220&lt;/td&gt;
&lt;td&gt;$200-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assignment&lt;/td&gt;
&lt;td&gt;$50-$150&lt;/td&gt;
&lt;td&gt;$80-$200&lt;/td&gt;
&lt;td&gt;$120-$240&lt;/td&gt;
&lt;td&gt;$160-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Project&lt;/td&gt;
&lt;td&gt;$100-$150&lt;/td&gt;
&lt;td&gt;$140-$200&lt;/td&gt;
&lt;td&gt;$180-$220&lt;/td&gt;
&lt;td&gt;$200-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Final&lt;/td&gt;
&lt;td&gt;$100-$200&lt;/td&gt;
&lt;td&gt;$140-$200&lt;/td&gt;
&lt;td&gt;$180-$240&lt;/td&gt;
&lt;td&gt;$220-$280&lt;/td&gt;
&lt;td&gt;$150-$400&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请直接给我留言,睡醒之后会马上回复您.请发送给我您的要求,due,相关文件&lt;br&gt;请加微信联系: &lt;img src=&quot;images/wechat.jpeg&quot; alt=&quot;WeChat&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;作业反馈&quot;&gt;&lt;a href=&quot;#作业反馈&quot; class=&quot;headerlink&quot; title=&quot;作业反馈&quot;&gt;&lt;/a&gt;作业反馈&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://holydudecs.github.io/2018/10/09/hello-world/"/>
    <id>http://holydudecs.github.io/2018/10/09/hello-world/</id>
    <published>2018-10-09T12:45:41.173Z</published>
    <updated>2018-10-09T12:45:41.173Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c/c++代写 数据结构算法:splayTree实现</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000011/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000011/</id>
    <published>2018-09-29T13:02:19.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写 数据结构预算法:在老师给的class基础上再完成splayTree,cacheLRU<br><a id="more"></a></p><p>#ifndef splayTree_H_</p><p>#define splayTree_H_</p><p>#include “rotateBST.h”</p><p>using std::cout;<br>using std::endl;<br>using std::max;</p><p>template<typename key,typename="" value=""><br>class rotateBST;</typename></p><p>template<typename key,typename="" value=""><br>class SplayTree:public rotateBST&lt;Key,Value&gt;<br>{<br>    public:<br>        SplayTree()<br>        {<br>            time_left_rotation=0;<br>            time_right_rotation=0;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator find(const Key&amp; key)<br>        {<br>            Node&lt;Key,Value&gt;<em> pre=NULL;<br>            Node&lt;Key,Value&gt;</em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            if(cur-&gt;getKey()==key)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>                return it;<br>            }<br>            pre=cur;<br>            while(cur!=NULL)<br>            {<br>                pre=cur;<br>                if(cur-&gt;getKey()&lt;key)//key is bigger ,go to right<br>                {<br>                    cur=cur-&gt;getRight();<br>                }else if(cur-&gt;getKey()&gt;key)//key is smaller,go to left<br>                {<br>                    cur=cur-&gt;getLeft();<br>                }else {<br>                    splay(cur);<br>                    typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>                    return it;<br>                }<br>            }<br>            splay(pre);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>            return it;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator findMin()<br>        {<br>            Node&lt;Key,Value&gt;<em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            while(cur-&gt;getLeft()!=NULL)<br>            {<br>                cur=cur-&gt;getLeft();<br>            }<br>            splay(cur);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>            return it;<br>        }<br>        typename SplayTree&lt;Key,Value&gt;::iterator findMax()<br>        {<br>            Node&lt;Key,Value&gt;</em> cur=this-&gt;mRoot;<br>            if(cur==NULL)<br>            {<br>                typename SplayTree&lt;Key,Value&gt;::iterator it(NULL);<br>                return it;<br>            }<br>            while(cur-&gt;getRight()!=NULL)<br>            {<br>                cur=cur-&gt;getRight();<br>            }<br>            splay(cur);<br>            typename SplayTree&lt;Key,Value&gt;::iterator it(cur);<br>            return it;<br>        }<br>        void deleteMinLeaf()<br>        {<br>            Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;<br>            if(cur==NULL) return ;</typename></p><pre><code>        while(cur-&gt;getLeft()!=NULL||cur-&gt;getRight()!=NULL)        {            if(cur-&gt;getLeft()!=NULL)            {                cur=cur-&gt;getLeft();            }else if(cur-&gt;getRight()!=NULL)            {                cur=cur-&gt;getRight();            }        }        remove(cur-&gt;getKey());    }    void deleteMaxLeaf()    {        Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;        if(cur==NULL) return;        while(cur-&gt;getLeft()!=NULL||cur-&gt;getRight()!=NULL)        {            if(cur-&gt;getLeft()!=NULL)            {                cur=cur-&gt;getLeft();            }else if(cur-&gt;getRight()!=NULL)            {                cur=cur-&gt;getRight();            }        }        remove(cur-&gt;getKey());    }    void insert(const std::pair&lt;const Key,Value&gt;&amp; keyValuePair)    {        BinarySearchTree&lt;Key,Value&gt;::insert(keyValuePair);        Node&lt;Key,Value&gt;* cur=this-&gt;mRoot;        Key key=keyValuePair.first;        while(cur-&gt;getKey()!=key)        {            if(cur-&gt;getKey()&lt;key)//key is bigger            {                cur=cur-&gt;getRight();            }else if(cur-&gt;getKey()&gt;key)            {                cur=cur-&gt;getLeft();            }        }        splay(cur);    }    void remove(const Key&amp; key)    {        Node&lt;Key,Value&gt;* pre=removeHelper(key);        splay(pre);    }private:    Node&lt;Key,Value&gt;* splay(Node&lt;Key,Value&gt;* nod,Key k);//stand splay    typename SplayTree&lt;Key,Value&gt;::iterator findHelper(Node&lt;Key,Value&gt;* nod,const Key&amp; key);    Node&lt;Key,Value&gt;* removeHelper(const Key&amp; key)    {        if(this-&gt;mRoot==NULL) return NULL;        Key k=key;        Node&lt;Key,Value&gt;* nod=this-&gt;mRoot;        Node&lt;Key,Value&gt;* pat=NULL;        while(nod)        {            if(nod-&gt;getKey()&lt;k)            {                nod=nod-&gt;getRight();            }else if(nod-&gt;getKey()&gt;k)            {                nod=nod-&gt;getLeft();            }else            {                if(nod-&gt;getLeft()==NULL&amp;&amp;nod-&gt;getRight()==NULL)                {                    if(nod-&gt;getParent()==NULL)                    {                        this-&gt;mRoot=NULL;                        pat=nod-&gt;getParent();                        delete nod;                        nod=NULL;                        break;                    }else                    {                        Node&lt;Key,Value&gt;* p=nod-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(NULL);                            pat=nod-&gt;getParent();                            delete nod;                            nod=p;                            break;                        }else if(p-&gt;getRight()==nod)                        {                            p-&gt;setRight(NULL);                            pat=nod-&gt;getParent();                            delete nod;                            nod=p;                            break;                        }                    }                }else if(nod-&gt;getLeft()!=NULL)                {                    Node&lt;Key,Value&gt;* pre=nod-&gt;getLeft();                    while(pre-&gt;getRight()!=NULL)                    {                        pre=pre-&gt;getRight();                    }                    Node&lt;Key,Value&gt;* sis=new Node&lt;Key,Value&gt;(pre-&gt;getKey(),pre-&gt;getValue(),nod-&gt;getParent());                    sis-&gt;setLeft(nod-&gt;getLeft());                    sis-&gt;setRight(nod-&gt;getRight());                    if(sis-&gt;getParent()==NULL) this-&gt;mRoot=sis;                    else {                        Node&lt;Key,Value&gt;* p=sis-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(sis);                        }else                        {                            p-&gt;setRight(sis);                        }                    }                    Node&lt;Key,Value&gt;* left=nod-&gt;getLeft();                    if(left!=NULL)                    {                        left-&gt;setParent(sis);                    }                    Node&lt;Key,Value&gt;* right=nod-&gt;getRight();                    if(right!=NULL)                    {                        right-&gt;setParent(sis);                    }                    pat=nod-&gt;getParent();                    delete nod;                    k=pre-&gt;getKey();                    if(pre-&gt;getParent()!=sis)                    {                        nod=pre-&gt;getParent();                    }else                    {                        nod=sis-&gt;getLeft();                    }                }else                {                    Node&lt;Key,Value&gt;* suc=nod-&gt;getRight();                    while(suc-&gt;getLeft()!=NULL)                    {                        suc=suc-&gt;getLeft();                    }                    Node&lt;Key,Value&gt;* sis=new Node&lt;Key,Value&gt;(suc-&gt;getKey(),suc-&gt;getValue(),nod-&gt;getParent());                    sis-&gt;setLeft(nod-&gt;getLeft());                    sis-&gt;setRight(nod-&gt;getRight());                    if(sis-&gt;getParent()==NULL) this-&gt;mRoot=sis;                    else {                        Node&lt;Key,Value&gt;* p=sis-&gt;getParent();                        if(p-&gt;getLeft()==nod)                        {                            p-&gt;setLeft(sis);                        }else                        {                            p-&gt;setRight(sis);                        }                    }                    Node&lt;Key,Value&gt;* l=sis-&gt;getLeft();                    if(l!=NULL)                    {                        l-&gt;setParent(sis);                    }                    Node&lt;Key,Value&gt;* r=sis-&gt;getRight();                    if(r!=NULL)                    {                        r-&gt;setParent(sis);                    }                    pat=nod-&gt;getParent();                    delete nod;                    k=suc-&gt;getKey();                    if(suc-&gt;getParent()!=sis)                    { nod=suc-&gt;getParent();                    }else                    { nod=sis-&gt;getRight();  }                }            }        }        while(nod)        {            Node&lt;Key,Value&gt;* node=nod;            if(node-&gt;getLeft()==NULL&amp;&amp;node-&gt;getRight()==NULL) node-&gt;setHeight(1);            else if(node-&gt;getLeft()==NULL) node-&gt;setHeight(node-&gt;getRight()-&gt;getHeight()+1);            else if(node-&gt;getRight()==NULL) node-&gt;setHeight(node-&gt;getLeft()-&gt;getHeight()+1);            else node-&gt;setHeight(max(node-&gt;getLeft()-&gt;getHeight(),node-&gt;getRight()-&gt;getHeight())+1);            nod=nod-&gt;getParent();        }        return pat;    }    int time_left_rotation;    int time_right_rotation;protected:    void splay(Node&lt;Key,Value&gt;* x)//splay the given node to the root//the r is existed    {        if(x==NULL) return ;        Node&lt;Key,Value&gt;* p=x-&gt;getParent();        if(p==NULL) return ;        Node&lt;Key,Value&gt;* g=p-&gt;getParent();        if(g==NULL)//p is root        {            if(p-&gt;getLeft()==x)            {                rotateBST&lt;Key,Value&gt;::rightRotate(p);                return ;            }else if(p-&gt;getRight()==x)            {                rotateBST&lt;Key,Value&gt;::leftRotate(p);                return ;            }        }        if(g-&gt;getLeft()==p&amp;&amp;p-&gt;getLeft()==x)//left left        {            rotateBST&lt;Key,Value&gt;::rightRotate(g);            rotateBST&lt;Key,Value&gt;::rightRotate(p);            time_right_rotation+=2;        }else if(g-&gt;getLeft()==p&amp;&amp;p-&gt;getRight()==x)        {            rotateBST&lt;Key,Value&gt;::leftRotate(p);            rotateBST&lt;Key,Value&gt;::rightRotate(g);            time_left_rotation+=1;            time_right_rotation+=1;        }else if(g-&gt;getRight()==p&amp;&amp;p-&gt;getRight()==x)        {            rotateBST&lt;Key,Value&gt;::leftRotate(g);            rotateBST&lt;Key,Value&gt;::leftRotate(p);            time_left_rotation+=2;        }else if(g-&gt;getRight()==p&amp;&amp;p-&gt;getLeft()==x)        {            rotateBST&lt;Key,Value&gt;::rightRotate(p);            rotateBST&lt;Key,Value&gt;::leftRotate(g);            time_left_rotation+=1;            time_right_rotation+=1;        }        splay(x);    }</code></pre><p>};</p><pre><code>template&lt;typename Key,typename Value&gt;</code></pre><p>typename SplayTree&lt;Key,Value&gt;::iterator SplayTree&lt;Key,Value&gt;:: findHelper(Node&lt;Key,Value&gt;* nod,const Key&amp; k)<br>{<br>    if(nod==NULL)<br>    {<br>        typename SplayTree&lt;Key,Value&gt;::iterator end(NULL);<br>        return end;<br>    }<br>    if(nod-&gt;getKey()&lt;k)//k is on the right subtree<br>    {<br>        return findHelper(nod-&gt;getRight(),k);<br>    }else if(nod-&gt;getKey()&gt;k)// k is on the left subtree<br>    {<br>        return findHelper(nod-&gt;getLeft(),k);<br>    }else {<br>        typename SplayTree&lt;Key,Value&gt;::iterator it(nod);<br>        return it;<br>    }<br>}</p><p>#endif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写 数据结构预算法:在老师给的class基础上再完成splayTree,cacheLRU&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++代写:大数加减乘除</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000010/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000010/</id>
    <published>2018-09-29T12:58:44.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>代写一个大数加减乘除的计算器,通过所有测试<br><a id="more"></a><br>COSC2430: Programming and Data Structures<br>HW2: Evaluate Arithmetic Expressions using stack<br>1<br>Introduction<br>You will create a C++ program that can evaluate arithmetic expressions with integer numbers having any number of<br>digits. These numbers are an alternative to fixed size integers or floating point numbers that always have a maximum<br>number of accurate digits (dependent on size of CPU register).<br>2<br>Input and Output<br>The input is a regular text file, where each line is terminated with an end-of-line character(s). Each line will contain<br>an arithmetic expression. Operators + − ∗ is mandatory. 10% extra credits for operator /. The program should display<br>the input expression and the results, separated with =. You need to check whether the expression is valid or not. If one<br>expression is not valid, skip it and continue to process next expression.<br>Input example:<br>0<em>00000000000000000+0000000000000001<br>(1+2)</em>(1000+2000)<br>(+1+2)<em>(1000+2000)<br>((1+2)</em>(1000+2000))<em>(1+10000)<br>(1+2)</em>(1000+2000))<em>(1+10000)<br>(1000000000000000-1)<br>9999999999999999999999/9999999999999999999999<br>(-100000+10000)</em>8<br>((-1))-(-1)<br>Output example:<br>0<em>00000000000000000+0000000000000001=1<br>(1+2)</em>(1000+2000)=9000<br>(+1+2)<em>(1000+2000)=9000<br>((1+2)</em>(1000+2000))<em>(1+10000)=90009000<br>(1000000000000000-1)=999999999999999<br>9999999999999999999999/9999999999999999999999=1<br>(-100000+10000)</em>8=-720000<br>((-1))-(-1)=0<br>3<br>Program input and output specification<br>The main program should be called infinitearithmetic. Call syntax at the OS prompt:<br>infinitearithmetic input=input1.txt<br>Assumptions:<br>• The file is a small plain text file (say &lt; 10000 expressions); no need to handle binary files.• Only integer numbers as input (no decimals!). Input numbers may have leading zeroes. Output number will be<br>written without leading zeroes (i.e. eliminate them).<br>• Operators: + − ∗/. 10% extra credits for operator /.<br>• Keep in mind a single + or can be a sign instead of an operator.<br>• You can assume the input are only integers and the ouptut is only an integer. Therefore, you can truncate the<br>decimal part when evaluating division.<br>• do not break an arithmetic expression into multiple lines as it will mess testing.<br>4<br>Requirements<br>• Homework is individual. Your homework will be automatically screened for code plagiarism against code from<br>the other students and code from external sources. If you copy/download source code from the Internet or a<br>book it is better you acknowledge it in your comments, instead of the TAs detecting it. Code that is detected<br>to be copied from another student (for instance, renaming variables, changing for and while loops, changing<br>indentation, etc) will result in ”Fail” in the course and being reported to UH upper administration.<br>• std::stack is not allowed. Please implement your own stack.<br>• Remove leading zeroes from the result (e.g. 1, instead of 00001; 0 instead of 00000).<br>• timeout is set to 10s.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代写一个大数加减乘除的计算器,通过所有测试&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转二叉树 rotateBST</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000009/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000009/</id>
    <published>2018-09-29T12:54:09.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写<br><a id="more"></a></p><p>#ifndef rotateBST_H_</p><p>#define rotateBST_H</p><p>#include <vector></vector></p><p>#include “bst.h”<br>using namespace std;</p><p>template <typename key,typename="" value=""><br>class BinarySearchTree;</typename></p><p>template <typename key,typename="" value=""><br>class rotateBST:public BinarySearchTree&lt;Key,Value&gt;</typename></p><p>{<br>    public:<br>        int sameKeys(const rotateBST&lt;Key,Value&gt;&amp; t2) const;//if this have all the same keys with t2<br>        void transform(rotateBST&lt;Key,Value&gt;&amp; t2)const ;<br>    protected:<br>        void leftRotate(Node&lt;Key,Value&gt;<em> r);<br>        void rightRotate(Node&lt;Key,Value&gt;</em> r);<br>    private:<br>        void recurHelper(Node&lt;Key,Value&gt;<em> nod1,Node&lt;Key,Value&gt;</em> nod2,rotateBST&lt;Key,Value&gt;&amp; t2) const;//we make left child .right of nd2 ok<br>        int UpdateHeight(Node&lt;Key,Value&gt;* nod);</p><p>};</p><p>template <typename key,typename="" value=""><br>int rotateBST&lt;Key,Value&gt;::sameKeys(const rotateBST&lt;Key,Value&gt;&amp; t2) const<br>{<br>    typename rotateBST&lt;Key,Value&gt;::iterator it1(this-&gt;getSmallestNode());<br>    typename rotateBST&lt;Key,Value&gt;::iterator end1(NULL);<br>    typename rotateBST&lt;Key,Value&gt;::iterator it2(t2.getSmallestNode());<br>    typename rotateBST&lt;Key,Value&gt;::iterator end2(NULL);<br>    while(it1!=end1&amp;&amp;it2!=end2)<br>    {<br>        if((<em>it1).first!=(</em>it2).first)<br>        {<br>            return false;<br>        }<br>        ++it1;<br>        ++it2;<br>    }<br>    if(it1!=end1||it2!=end2)<br>    {<br>        return false;<br>    }</typename></p><pre><code>return true;</code></pre><p>}</p><p>template <typename key,typename="" value=""><br>void rotateBST&lt;Key,Value&gt;::transform(rotateBST&lt;Key,Value&gt;&amp; t2) const<br>{<br>    if(sameKeys(t2)==false)<br>    {<br>        return;<br>    }</typename></p><pre><code>recurHelper(NULL,NULL,t2);</code></pre><p>}</p><p>template <typename key,typename="" value=""><br>void rotateBST&lt;Key,Value&gt;::recurHelper(Node&lt;Key,Value&gt;<em> nod1,Node&lt;Key,Value&gt;</em> nod2,rotateBST&lt;Key,Value&gt;&amp; t2) const//we make left child .right of nd2 ok<br>{<br>    if(nod1==NULL&amp;&amp;nod2==NULL)<br>    {<br>        while(t2.mRoot-&gt;getLeft()!=NULL)<br>        {<br>            t2.rightRotate(t2.mRoot);</typename></p><pre><code>    }    auto p=t2.mRoot;    while(p-&gt;getRight()!=NULL)    {        while(p-&gt;getRight()-&gt;getLeft()!=NULL)        {            t2.rightRotate(p-&gt;getRight());        }        p=p-&gt;getRight();    }    while(this-&gt;mRoot-&gt;getKey()!=t2.mRoot-&gt;getKey())    {        t2.leftRotate(t2.mRoot);    }    recurHelper(this-&gt;mRoot,t2.mRoot,t2);}else{    if(nod2-&gt;getLeft()!=NULL)    {        //make the left of nod2 linked list        while(nod2-&gt;getLeft()-&gt;getLeft()!=NULL)        {            t2.rightRotate(nod2-&gt;getLeft());        }        auto nod=nod2-&gt;getLeft();        while(nod-&gt;getRight()!=NULL)        {            while(nod-&gt;getRight()-&gt;getLeft()!=NULL)            {                t2.rightRotate(nod-&gt;getRight());            }            nod=nod-&gt;getRight();        }        //make key same        while(nod2-&gt;getLeft()-&gt;getKey()!=nod1-&gt;getLeft()-&gt;getKey())        {            t2.leftRotate(nod2-&gt;getLeft());        }        recurHelper(nod1-&gt;getLeft(),nod2-&gt;getLeft(),t2);    }    if(nod2-&gt;getRight()!=NULL)    {        //make the left of nod2 linked list        while(nod2-&gt;getRight()-&gt;getLeft()!=NULL)        {            t2.rightRotate(nod2-&gt;getRight());        }        auto nod=nod2-&gt;getRight();        while(nod-&gt;getRight()!=NULL)        {            while(nod-&gt;getRight()-&gt;getLeft()!=NULL)            {                t2.rightRotate(nod-&gt;getRight());            }            nod=nod-&gt;getRight();        }        //make key same        while(nod2-&gt;getRight()-&gt;getKey()!=nod1-&gt;getRight()-&gt;getKey())        {            t2.leftRotate(nod2-&gt;getRight());        }        recurHelper(nod1-&gt;getRight(),nod2-&gt;getRight(),t2);    }    nod2-&gt;setHeight(nod1-&gt;getHeight());}</code></pre><p>}</p><pre><code>template &lt;typename Key,typename Value&gt;</code></pre><p>void rotateBST&lt;Key,Value&gt;::leftRotate(Node&lt;Key,Value&gt;<em> r)<br>{<br>    if(r==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> z=r;<br>    Node&lt;Key,Value&gt;<em> y=r-&gt;getRight();<br>    if(y==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> t2=y-&gt;getLeft();<br>    Node&lt;Key,Value&gt;* p=z-&gt;getParent();<br>    //ok</p><pre><code>//parentif(p==NULL) this-&gt;mRoot=y;else if(p-&gt;getLeft()==z) p-&gt;setLeft(y);else if(p-&gt;getRight()==z) p-&gt;setRight(y);//zz-&gt;setRight(t2);z-&gt;setParent(y);//yy-&gt;setParent(p);y-&gt;setLeft(z);//t2if(t2!=NULL)    t2-&gt;setParent(z);//deal z heightif(z-&gt;getLeft()==NULL&amp;&amp;t2==NULL){    z-&gt;setHeight(1);}else if(z-&gt;getLeft()==NULL){    z-&gt;setHeight(t2-&gt;getHeight()+1);}else if(t2==NULL){    z-&gt;setHeight(z-&gt;getLeft()-&gt;getHeight()+1);}else{    z-&gt;setHeight(max(z-&gt;getLeft()-&gt;getHeight(),t2-&gt;getHeight())+1);}if(y-&gt;getRight()!=NULL){    y-&gt;setHeight(max(y-&gt;getRight()-&gt;getHeight(),z-&gt;getHeight())+1);}else{    y-&gt;setHeight(z-&gt;getHeight()+1);}if(p!=NULL){    if(p-&gt;getLeft()!=NULL&amp;&amp;p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(max( p-&gt;getLeft()-&gt;getHeight(),p-&gt;getRight()-&gt;getHeight()  )+1);    }else if(p-&gt;getLeft()!=NULL)    {        p-&gt;setHeight(p-&gt;getLeft()-&gt;getHeight()+1);    }else if(p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(p-&gt;getRight()-&gt;getHeight()+1);    }else    {        p-&gt;setHeight(1);    }}return ;</code></pre><p>}</p><pre><code>template &lt;typename Key,typename Value&gt;</code></pre><p>void rotateBST&lt;Key,Value&gt;::rightRotate(Node&lt;Key,Value&gt;<em> r)<br>{<br>    if(r==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> z=r;<br>    Node&lt;Key,Value&gt;<em> y=z-&gt;getLeft();<br>    if(y==NULL) return ;<br>    Node&lt;Key,Value&gt;</em> t3=y-&gt;getRight();<br>    Node&lt;Key,Value&gt;* p=z-&gt;getParent();<br>    //ok</p><pre><code>//parentif(p==NULL) this-&gt;mRoot=y;else if(p-&gt;getLeft()==z) p-&gt;setLeft(y);else if(p-&gt;getRight()==z) p-&gt;setRight(y);//zz-&gt;setLeft(t3);z-&gt;setParent(y);//yy-&gt;setParent(p);y-&gt;setRight(z);//t3if(t3!=NULL)    t3-&gt;setParent(z);//deal z heightif(z-&gt;getRight()==NULL&amp;&amp;t3==NULL){    z-&gt;setHeight(1);}else if(z-&gt;getRight()==NULL){    z-&gt;setHeight(t3-&gt;getHeight()+1);}else if(t3==NULL){    z-&gt;setHeight(z-&gt;getRight()-&gt;getHeight()+1);}else{    z-&gt;setHeight(max(z-&gt;getLeft()-&gt;getHeight(),z-&gt;getRight()-&gt;getHeight())+1);}if(y-&gt;getLeft()!=NULL){    y-&gt;setHeight(max(y-&gt;getLeft()-&gt;getHeight(),z-&gt;getHeight())+1);}else{    y-&gt;setHeight(z-&gt;getHeight()+1);}if(p!=NULL){    if(p-&gt;getLeft()!=NULL&amp;&amp;p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(max( p-&gt;getLeft()-&gt;getHeight(),p-&gt;getRight()-&gt;getHeight()  )+1);    }else if(p-&gt;getLeft()!=NULL)    {        p-&gt;setHeight(p-&gt;getLeft()-&gt;getHeight()+1);    }else if(p-&gt;getRight()!=NULL)    {        p-&gt;setHeight(p-&gt;getRight()-&gt;getHeight()+1);    }else    {        p-&gt;setHeight(1);    }}return ;</code></pre><p>}</p><p>#endif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="c/c_++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>cs作业代写 哈弗曼树</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000008/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000008/</id>
    <published>2018-09-29T12:50:25.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>Final Project: Huffman Encoding<br><a id="more"></a><br>Assigned: April 27, 2018</p><p>Due: May 15, 2018 at 5pm<br>Summary: In this assignment, you will apply several of the data structures we have used<br>in class to create a file compression/decompression system using the Huffman<br>Encoding algorithm. You will have some time in class to work on the<br>assignment with your partner, but plan to spend time outside of class on the<br>assignment as well.<br>Learning To experience full-system object oriented design and appropriately use<br>Goals: provided data structures.<br>Collaboration: For this assignment, you will submit work in partners assigned in class. While<br>you can work with your partner any way you wish, I encourage you to use a<br>pair-programming approach while working on Class 1 in particular, whereas<br>Classes 2 and 3 can be worked on independently.<br>Submission : Turnin Form<br>Assignment<br>In this assignment, you will be working on information compression using a Huffman Tree. It is a<br>large assignment, so start with your partner early. You can choose to either work on it in a pair-<br>programming approach or by dividing some of the interfaces described below, implementing them<br>independently, and integrating them. While test-driven development for individual classes is<br>recommended, submission of test cases is not required. Bare-bones starter code is provided here.<br>At this point, you should be familiar with the core standard library data structures such as strings,<br>   vectors, lists, stacks, queues, sets, and maps. Use them judiciously in your assignment!<br>   Additionally, you are provided with utility classes for bitstreams, objects that work like regular<br>   streams but read and write individual bits instead of multi-bit or multi-character data elements.<br>   Note that while the interfaces below are required, you may also write additional internal methods if<br>   it helps you organize your code. Do make sure that different classes and declared in different<br>   header files, implemented in different implementation files, and added to the Makefile for<br>   compilation.<br>   Class 1: The decision tree (40%)<br>   In a prior assignment, you implemented a special-purpose decision tree where internal and<br>   external nodes each held different kinds of information. In this assignment, you will create a new<br>   decision tree class that stores different information. The Huffman decision tree is a binary tree<br>   where every node has a “weight” property describing the cumulative frequencies of everything in<br>   that subtree, and leaves additionally have a “value” property that describes the character<br>   represented by that leaf. A description of the Huffman tree construction algorithm is in section 12.4<br>   of our textbook. You are strongly encouraged to review the previous decision tree assignment to<br>   make this component easier.<br>   The Huffman tree class should implement the following interfaces:<br>       <a href="http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml" target="_blank" rel="noopener">http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml</a><br>       1/35/5/2018<br>       CS 270, 2018S: Final Project<br>       HuffmanTree(const map&lt;char, float&gt;&amp;): construct a Huffman Tree from a set of characters<br>                                             with frequencies. Your constructor should use the algorithms from the textbook and in class<br>                                             to build a tree by merging subtrees together. Remember, a priority queue of Nodes is going<br>                                             to be very helpful here!<br>                                             void writeTree(ostream&amp;): write the Huffman tree as text to a stream. The encoding format<br>                                                                       for the Huffman decision tree is similar to the question-based decision tree. Print one node<br>                                                                       per line: if the node is an internal node, begin the line with “NODE:”, followed by the<br>                                                                       frequency of the characters in that subtree. If a node is a leaf, begin the line with “LEAF:”,<br>                                                                       followed by the character, followed by the frequency of that character. A simple tree might<br>                                                                       look like:<br>                                                                       NODE: 1.0<br>                                                                       LEAF: a 0.5<br>                                                                       LEAF: b 0.5<br>                                                                       HuffmanTree(istream&amp;): construct a Huffman Tree from an already-open stream, according to<br>    the same tree format described above. When done, the constructor should use the seekg<br>                                                                                         method to reset the istream to the beginning of its content (like closing and reopening the file,<br>                                                                                                 without actually closing and reopening it.)<br>                                                                                              char decode(ibitstream&amp;): beginning at the top of Huffman tree, decode a single character<br>                                                                                                                        from a stream of bits. Use the ibitstream member function “readBit” to read individual bits.<br>                                                                                                                        Traverse the tree, and return the decoded character. You may want to revisit the traversal<br>                                                                                                                        code of the previous Decision Tree data structure as a refresher.<br>                                                                                                                        map&lt;char, std::vector<int>&gt; getEncodings(): Traverse the Huffman tree internally to construct<br>                                                                                                                                                                    a map from each character represented in the Huffman Tree to the bit coding that would be<br>                                                                                                                                                                    required to reach that character in the tree. (Hint: think about using a vector as a stack.<br>                                                                                                                                                                            Keep track of what choices you have made in your traversal by pushing items on to the back<br>                                                                                                                                                                            of the vector, and when you reach a leaf, the vector will contain the sequence of choices<br>                                                                                                                                                                            made to reach that leaf. Add that vector to the map, and when you return from a recursion<br>                                                                                                                                                                            step in the traversal, pop the last decision-item off the end of the stack. All of the entries in<br>                                                                                                                                                                            the vector should be either 0 or 1.)<br>                                                                                                                                                                    To test your HuffmanTree separately from an encoder, decoder, you’ll have to manually construct<br>                                                                                                                                                                    the map and stream arguments in your test cases. Recall that cout can be used as an ostream,<br>                                                                                                                                                                    cin as an istream. Bitstreams are a little different: take a look at the ibitstreamtest.cpp file to see<br>                                                                                                                                                                    an example of how to create and use stringbitstream objects that might help you in your test cases.<br>                                                                                                                                                                    Class 2: The Huffman Encoder (25%)<br>                                                                                                                                                                    This class will have a HuffmanTree and an istream&amp; as fields, and will use it to manage the<br>                                                                                                                                                                    encoding and decoding of files through the following interfaces<br>                                                                                                                                                                    HuffmanEncoder(istream&amp;): create an encoder and construct the HuffmanTree for the given<br>                                                                                                                                                                                              istream. When the construction is completed, reset the istream to the beginning of its input<br>                                                                                                                                                                                              using the seekg function with the std::ios::beg position marker, e.g.<br>                                                                                                                                                                                              “mystream.seekg(0,std::ios::beg);”<br>                                                                                                                                                                                              int writeEncodedText(obitstream&amp;): write the original text in encoded format to the given,<br>                                                                                                                                                                                              open obitstream, and return the number of characters encoded. Remember to reset the<br>                                                                                                                                                                                                                                 istream position at the end of the function.<br>                                                                                                                                                                                                                                 void writeTree(ostream&amp;): invokes the writeTree function of the HuffmanTree to write the tree<br>                                                                                                                                                                                                                                                           used to encode this istream to the given output stream.<br>                                                                                                                                                                                                                                                           Class 3: The Huffman Decoder (25%)<br>                                                                                                                                                                                                                                                           <a href="http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml" target="_blank" rel="noopener">http://cs.whitman.edu/~strattja/cs/270/2018S/hw/fp.huffman.shtml</a><br>                                                                                                                                                                                                                                                               2/35/5/2018<br>                                                                                                                                                                                                                                                               CS 270, 2018S: Final Project<br>                                                                                                                                                                                                                                                               This class will have a HuffmanTree as a field, and will use it to manage the decoding of a<br>                                                                                                                                                                                                                                                               compressed stream as produced by the encoder.<br>                                                                                                                                                                                                                                                               HuffmanDecoder(istream&amp;): create a decoder and construct the HuffmanTree from the given<br>                                                                                                                                                                                                                                                                                         istream, which stores the tree in text format (as produced by writeTree).<br>                                                                                                                                                                                                                                                                                         void decodeText(int, ibitstream&amp;, ostream&amp;): decode the message from the given input bit<br>                                                                                                                                                                                                                                                                                                                                      stream into the output character stream. The first argument indicates the expected number<br>                                                                                                                                                                                                                                                                                                                                      of characters to be decoded.<br>    void writeTree(ostream&amp;): invokes the writeTree function of the HuffmanTree to write the<br>                              tree. (This is primarily for debugging purposes, most applications will not need it.)<br>                              Above and Beyond: User application (10%)<br>                                                To complete the assignment, you must design and write some command-line user interface to<br>                                                enable a user to encode and decode text with the classes you have built. As some suggestions to<br>                                                get you started thinking, you could asking the user to provide names for files to read and write<br>                                                through prompts or the command-line, or asking the user to type strings and print the huffman-<br>                                                encoded results as ‘1’ and ‘0’ characters to the terminal, or write multiple different applications with<br>                                                different main functions for handling encoding and decoding using the same libraries. Whichever<br>                                                route you choose, start by looking up the documentation for the kind of streams you want to deal<br>                                                with - files are handled through ofstreams and ifstreams (or ofbitstreams and ifbitstreams) and<br>                                                strings can be processed using stringstream objects. Good links for the Stanford bitstream<br>                                                libraries here, and the C++ standard i/o library here. Talk with your partner to decide how you want<br>                                                your application to be informative, artistic, utilitarian, fun, or any or all of the above. Whatever<br>                                                interface you design and choose, include a README.txt file that describes what you did and how<br>                                                to use your application.<br>                                                Submitting your work<br>                                                Make sure your files are named correctly as specified above. In your comments at the top, make<br>                                                sure you:<br>                                                acknowledge any help or outside sources, in accordance with the academic honesty policy;<br>                                                describe any known bugs in the program.<br>                                                Rezip your materials using the command “zip -r mywhitmanID_Huffman.zip FP_huffman” in the<br>                                                folder containing the final project unzipped package. Submit your completed package using the<br>                                                online turnin form. Be sure to select the Final Project.</int></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Final Project: Huffman Encoding&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写 cs代写 Book Ciper</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000007/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000007/</id>
    <published>2018-09-29T12:40:24.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写 cs代写 Book Ciper<br><a id="more"></a></p><h1 id="Project-2-–-Book-Cipher"><a href="#Project-2-–-Book-Cipher" class="headerlink" title="Project #2 – Book Cipher"></a>Project #2 – Book Cipher</h1><p>Course<br>Professor<br>Assigned<br>Due<br>Weight<br>Student Name<br>INFO-1156 Object-Oriented Programming in C++<br>Garth Santor, Lianne Wong, and Janice Manning<br>March 19 th 2018<br>April 6 th 2018 @ 11:59pm<br>5%<br>Project Description<br>Create two C++ console applications; one that encodes a text message using a book<br>cipher, and another that decodes the message coded by the previous program.<br>Program Interfaces<br>The encoder should have the following command-line interface:<br>bcencode.exe bookfile messagefile codedfile<br>The decoder should have the following command-line interface:<br>bcdecode.exe bookfile codedfile messagefile<br>Where:<br>• bookfile is the name of the ASCII text file containing the book used to<br>encode/decode the message.<br>• messagefile is the name of the ASCII text file containing the message to be<br>encoded<br>• codedfile is the name of the ASCII text file containing the offset numbers<br>Encoding rules<br>Encode each character of the source file by replacing it with two numbers, the first<br>representing the line in the book (zero-based), and the second the offset to that character<br>in that line (also zero-based). Any method of choosing which offset to use is acceptable<br>so long as the same offset isn’t used repeatedly.<br>At the end of running bcencoder, a codedfile is created with offsets.<br>At the end of running bcdecoder, a messagefile is created with the message.<br>The encoded file must be just a file of the exact offsets of the message file.<br>bookfile: “ABCDEFGHIJKLM\nNOPQRSTUVWXYZ”<br>messagefile: “ACER”<br>codedfile: 0x00000000 0x00000000 0x00000000 0x00000002 0x00000000 0x00000004<br>0x00000001 0x00000004<br>Encoding background<br>To read more about encoding messages using the book cipher see:<br><a href="https://en.wikipedia.org/wiki/Book_cipher" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Book_cipher</a><br>In this program, you are encoding letters, not the words. The encoded file will store the<br>number in binary.<br>bctest.exe<br>‘bctest.exe’ is a program that can perform some tests on your encoder and decoder<br>programs. The test program should be placed into the same folder as your executable<br>files. If your programs are properly called ‘bcencode.exe’ and ‘bcdecode.exe’ the test<br>program will automatically execute your programs at appropriate times during the test.<br>Grading Criteria<br>Functional Requirements<br>Encoder works<br>Decoder works<br>Both programs report errors if any of the input files<br>cannot be opened (indicating which file was the<br>problem).<br>The encoder program reports and quits if the message<br>cannot be encoded by the book file (i.e. A character in<br>the message to be encoded does not exist in the book<br>file), and reports which character cannot be encoded.<br>40%<br>40%<br>10% 40%<br>40%<br>10%<br>10% 10%<br>Non-functional requirements<br>Executables program are not named ‘bcencode.exe’ and<br>‘bcdecode.exe’<br>Coded message uses the same index repeatedly for the<br>same letter.<br>Penalties from C &amp; C++ Grading Guide v1.1.0<br>A guide to code/comment style can be found at C++ Style<br>Late submission<br>• One to five days late<br>• More than five days late<br>Total<br>-10% / each<br>-20%<br>Various<br>-10%/day<br>-100%<br>100% 100%<br>Submission</p><ol><li>Submit entire Visual Studio project directory to Fanshawe Online<br>a. Delete all debug and release directories. i<br>b. Submit in a .ZIP, .7z archive file.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写 cs代写 Book Ciper&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写:模拟数据库</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000006/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000006/</id>
    <published>2018-09-29T12:37:48.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写:使用hash快速模拟数据库的收发和对应关系<br><a id="more"></a></p><h1 id="COSC2430-Programming-and-Data-Structures"><a href="#COSC2430-Programming-and-Data-Structures" class="headerlink" title="COSC2430: Programming and Data Structures"></a>COSC2430: Programming and Data Structures</h1><h1 id="HW3-Database-System"><a href="#HW3-Database-System" class="headerlink" title="HW3: Database System"></a>HW3: Database System</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>You will write a C++ program to simulate database operation (add, get and delete).</p><h2 id="2-Input-and-Output-Specification"><a href="#2-Input-and-Output-Specification" class="headerlink" title="2 Input and Output Specification"></a>2 Input and Output Specification</h2><p>The records input file is very clean (but may contain duplicated records) and have uniform attributes(columns). Each<br>record stream begins with operation add, delete or get, then follows by a space and a record. For add operation, you<br>will need to add a record with full attributes. However, when you do delete or get operation, you may only have partial<br>attributes. For get operation, you need to output the result in the origin record order and an empty line.<br>Example of input files (between the lines)</p><h2 id="input1-txt"><a href="#input1-txt" class="headerlink" title="input1.txt"></a>input1.txt</h2><p>add {id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}<br>add {id:1234568,first:Peter,last:White,DOB:1997-05-22,GPA:3.8}<br>add {id:1654238,first:Nick,last:Park,DOB:1995-08-18,GPA:4.0}<br>add {id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}<br>get {GPA:4.0}<br>delete {first:Mary}<br>add {id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}</p><h2 id="get-last-Green-GPA-4-0"><a href="#get-last-Green-GPA-4-0" class="headerlink" title="get {last:Green,GPA:4.0}"></a>get {last:Green,GPA:4.0}</h2><h2 id="output1-txt"><a href="#output1-txt" class="headerlink" title="output1.txt"></a>output1.txt</h2><p>{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}<br>{id:1654238,first:Nick,last:Park,DOB:1995-08-18,GPA:4.0}<br>{id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}<br>{id:1234587,first:Katy,last:Green,DOB:1995-08-18,GPA:4.0}</p><h2 id="id-1234567-first-Mary-last-Green-DOB-1996-10-03-GPA-4-0"><a href="#id-1234567-first-Mary-last-Green-DOB-1996-10-03-GPA-4-0" class="headerlink" title="{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}"></a>{id:1234567,first:Mary,last:Green,DOB:1996-10-03,GPA:4.0}</h2><h2 id="3-Program-specification"><a href="#3-Program-specification" class="headerlink" title="3 Program specification"></a>3 Program specification</h2><p>The main program should be called ”database”. Call syntax is as follows (from the OS prompt):<br>./database input=input1.txt output=output1.txt<br>Notice that the file name will not necessarily be the same every time. Therefore, your program will have to take that<br>into account.</p><h2 id="4-Requirements"><a href="#4-Requirements" class="headerlink" title="4 Requirements"></a>4 Requirements</h2><p>• Homework is individual. Your homework will be automatically screened for code plagiarism against code from<br>the other students and code from external sources. If you copy/download source code from the Internet or a<br>book it is better you acknowledge it in your comments, instead of the TAs detecting it. Code that is detected<br>to be copied from another student (for instance, renaming variables, changing for and while loops, changing<br>indentation, etc) will result in ”Fail” in the course and being reported to UH upper administration.<br>• The maximum number of records is 100,000. Timeout is set to 2s. That said, your program must get the result<br>file in 2 seconds.<br>• For each operation add, get and delete, you need to do it in O(max(k, n)) time complexity at maximum,<br>where n is current number of records in the database, k is the number of attributes in one record. Failing<br>to do this is likely to get a timeout error. That said, hash table and binary search tree are preferred. Any<br>data structures and algorithms in stl library are allowed.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写:使用hash快速模拟数据库的收发和对应关系&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c_++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Database" scheme="http://holydudecs.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>java代写:韩国算法数据结构</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000005/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000005/</id>
    <published>2018-09-29T12:34:29.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>比较少见的韩语ppt,代写树的一类算法<br><a id="more"></a></p><p>자료 구조<br>숙제 #05<br>트리<br>2분반 마감 시간: 5월 3일 오후 11시 59분<br>1분반 마감 시간: 5월 6일 오후 11시 59분<br>2018/04/27<br>컴퓨터과학과<br>민경하<br>문제<br>• 다음과 같은 트리가 다음과 같은 형식으로 test.txt 파일<br>에 저장되어 있다.<br>문제<br>• 트리에 대한 자료 구조가 다음과 같이 정의되어 있다.<br>문제<br>• 위의 test.txt 파일로부터 한줄씩 트리에 대한 정보를 읽어들여<br>서 트리에 추가하는 과정을 통해서 트리를 완성한다.<br>문제<br>• 위의 test.txt 파일로부터 한줄씩 트리에 대한 정보를 읽어들여<br>서 트리에 추가하는 과정을 통해서 트리를 완성한다.<br>문제<br>• 위의 트리에 대해서 다음의 3 가지 연산을 구현할 것.<br>• degree (  ): 트리의 degree를 출력하시오.<br>• depth (  ): 트리의 depth를 출력하시오.<br>• width (  ): 트리의 width를 출력하시오.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较少见的韩语ppt,代写树的一类算法&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写:简单的c++作业</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000004/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000004/</id>
    <published>2018-09-29T06:40:24.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>代写一个查询系统,对数据进行快速读入,随后对数据进行查询.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct Data&#123;</span><br><span class="line">    char source[20];</span><br><span class="line">    char name[10];</span><br><span class="line">    int color;//色度</span><br><span class="line">    float ph;//ph 值</span><br><span class="line">    int Ga;//gai钙</span><br><span class="line">    int Mg;//镁</span><br><span class="line">    int Na;//钠</span><br><span class="line">    float radio;//放射性</span><br><span class="line">    struct Data* next;</span><br><span class="line">&#125;;//用链表</span><br><span class="line">//同时我们会做一个fake head</span><br><span class="line"></span><br><span class="line">struct Data* head ;</span><br><span class="line">/*struct Data* head = (struct Data*) malloc(sizeof(struct Data));*/</span><br><span class="line"></span><br><span class="line">struct Data* NewDataNode()</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* node=(struct Data*) malloc(sizeof(struct Data));</span><br><span class="line">    for(int i=0;i&lt;20;i++) node-&gt;source[i]=0;</span><br><span class="line">    for(int i=0;i&lt;10;i++) node-&gt;name[i]=0;</span><br><span class="line">    node-&gt;color=-1;</span><br><span class="line">    node-&gt;ph=-1;</span><br><span class="line">    node-&gt;Ga=-1;</span><br><span class="line">    node-&gt;Mg=-1;</span><br><span class="line">    node-&gt;Na=-1;</span><br><span class="line">    node-&gt;radio=-1;</span><br><span class="line">    node-&gt;next=NULL;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputData(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stdout,&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);</span><br><span class="line">    /*fprintf(stdout,&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);*/</span><br><span class="line">    /*printf(&quot;%s,%s,%d,%.1f,%d,%d,%d,%.3f\n&quot;,node-&gt;source,node-&gt;name,node-&gt;color,node-&gt;ph,node-&gt;Ga,node-&gt;Mg,node-&gt;Na,node-&gt;radio);*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int After(struct Data* l,struct Data * r)//l be after r?</span><br><span class="line">&#123;</span><br><span class="line">    if(l-&gt;radio&gt;r-&gt;radio) return 1;</span><br><span class="line">    if(l-&gt;radio&lt;r-&gt;radio) return 0;</span><br><span class="line">    if(l-&gt;Mg&lt;r-&gt;Mg) return 1;</span><br><span class="line">    if(l-&gt;Mg&gt;r-&gt;Mg) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertNode(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* tmp=head;</span><br><span class="line">    while(tmp-&gt;next&amp;&amp;After(node,tmp-&gt;next))</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct Data* next=tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next=node;</span><br><span class="line">    node-&gt;next=next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ValidString(char ch)</span><br><span class="line">&#123;</span><br><span class="line">    if(ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) return 1;</span><br><span class="line">    if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;) return 1;</span><br><span class="line">    if(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) return 1;</span><br><span class="line">    if(ch==13||ch==10) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eof=0;</span><br><span class="line"></span><br><span class="line">struct Data* ReadData(FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* node=NewDataNode();</span><br><span class="line"></span><br><span class="line">    char ch;</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;20&amp;&amp;(ch=fgetc(fp))!=&apos;,&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ch==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            free(node);</span><br><span class="line">            eof=1;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!ValidString(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">            free(node);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        /*printf(&quot;%dth ch:%d\n&quot;,i,ch);*/</span><br><span class="line">        if(ch!=&apos;\n&apos;&amp;&amp;ch!=13&amp;&amp;ch!=10)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;source[i]=ch;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==20||i==0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    /*printf(&quot;1\n&quot;);*/</span><br><span class="line"></span><br><span class="line">    i=0;</span><br><span class="line">    while(i&lt;10&amp;&amp;(ch=fgetc(fp))!=&apos;,&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;name[i]=ch;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==0||i==10)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        /*printf(&quot;\n2\n&quot;);*/</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rd=fscanf(fp,&quot;%d,%f,%d,%d,%d,%f&quot;,&amp;node-&gt;color,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na,&amp;node-&gt;radio);</span><br><span class="line">    if(rd!=6)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;读取错误\n&quot;);</span><br><span class="line">        /*printf(&quot;\n3\n&quot;);*/</span><br><span class="line">        free(node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InsertNode(node);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Better(struct Data* l, struct Data* r)//l&apos;s color ,ph ,Ga , Na, Mg should be less that r</span><br><span class="line">&#123;</span><br><span class="line">    if(l-&gt;color&gt;r-&gt;color) return 0;</span><br><span class="line">    if(l-&gt;Ga&gt;r-&gt;Ga) return 0;</span><br><span class="line">    if(l-&gt;Na&gt;r-&gt;Na) return 0;</span><br><span class="line">    if(l-&gt;Mg&gt;r-&gt;Mg) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BetterOutput(struct Data* node)</span><br><span class="line">&#123;</span><br><span class="line">    struct Data* tmp=head-&gt;next;</span><br><span class="line">    while(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Better(tmp,node))</span><br><span class="line">        &#123;</span><br><span class="line">            OutputData(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    head = (struct Data*) malloc(sizeof(struct Data));</span><br><span class="line">    FILE *fp=NULL;//打开文件</span><br><span class="line">    fp=fopen(&quot;samples.txt&quot;,&quot;r&quot;);</span><br><span class="line">    if(fp==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;File open error!\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //下面开始读取文件并存储到链表中</span><br><span class="line"></span><br><span class="line">    struct Data* tmp=head-&gt;next;</span><br><span class="line">    while(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        if(ReadData(fp)==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if(eof==1)//read the End Of File</span><br><span class="line">            &#123;</span><br><span class="line">                eof=0;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                /*GG*/</span><br><span class="line">                tmp=head;</span><br><span class="line">                while(tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    struct Data* next=tmp-&gt;next;</span><br><span class="line">                    free(tmp);</span><br><span class="line">                    tmp=next;</span><br><span class="line">                &#125;</span><br><span class="line">                fclose(fp);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*tmp=head-&gt;next;*/</span><br><span class="line">    /*while(tmp)*/</span><br><span class="line">    /*&#123;*/</span><br><span class="line">    /*Data* next=tmp-&gt;next;*/</span><br><span class="line">    /*OutputData(tmp);*/</span><br><span class="line">    /*tmp=next;*/</span><br><span class="line">    /*&#125;*/</span><br><span class="line"></span><br><span class="line">    //下面这个循环是在进行查询和搜索</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\n\n输入color ph Ga Mg Na的最大值(q开头结束)\n&quot;);</span><br><span class="line">        struct Data* node= NewDataNode();</span><br><span class="line">        char ch=0;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        if(ch==&apos;q&apos;)</span><br><span class="line">            break;</span><br><span class="line">        node-&gt;color=ch-&apos;0&apos;;</span><br><span class="line">        while((ch=getchar())!=&apos; &apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;color=node-&gt;color*10+ch-&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        fscanf(stdin,&quot;%f%d%d%d&quot;,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na);</span><br><span class="line">        /*OutputData(node);*/</span><br><span class="line">        while(getchar()!=&apos;\n&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        /*fscanf(stdin,&quot;%d%f%d%d%d&quot;,&amp;node-&gt;color,&amp;node-&gt;ph,&amp;node-&gt;Ga,&amp;node-&gt;Mg,&amp;node-&gt;Na);*/</span><br><span class="line">        BetterOutput(node);</span><br><span class="line">        free(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //free malloc memory</span><br><span class="line">    tmp=head;</span><br><span class="line">    while(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        struct Data* next=tmp-&gt;next;</span><br><span class="line">        free(tmp);</span><br><span class="line">        tmp=next;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代写一个查询系统,对数据进行快速读入,随后对数据进行查询.&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>c/c++代写:多线程编程</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000003/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000003/</id>
    <published>2018-09-29T06:31:17.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>c/c++代写:多线程编程<br>完成一个多线程变成,c/c++代写<br><a id="more"></a></p><h1 id="CS305-作業系統概論-Homework-2-Multithreading"><a href="#CS305-作業系統概論-Homework-2-Multithreading" class="headerlink" title="CS305 作業系統概論 Homework #2 Multithreading"></a>CS305 作業系統概論 Homework #2 Multithreading</h1><h3 id="2018-04-18"><a href="#2018-04-18" class="headerlink" title="2018.04.18"></a>2018.04.18</h3><h2 id="一、-作業目的"><a href="#一、-作業目的" class="headerlink" title="一、 作業目的"></a>一、 作業目的</h2><p>熟悉如何使用Pthreads的API,撰寫multithreaded program。</p><h2 id="二、-作業內容"><a href="#二、-作業內容" class="headerlink" title="二、 作業內容"></a>二、 作業內容</h2><p>【大數據中的關鍵文件】為了要在許多文件中找出關鍵文件,L公司想要來利用電腦科技來達成目標。<br>對L公司而言,在一個有M個文件的文件集合D={d 1 ,d 2 ,…,d M }中,關鍵文件d k 就是與其他文件的相似度總<br>和最高的文件。但對於如何快速計算文件的相似度,L公司卻毫無頭緒。<br>於是L公司來到風之塔學院尋求幫助。對於這個大數據問題,風之塔學院的C教授帶著他的高徒開發這個<br>程式。C教授決定先使用傑卡德相似係數(Jaccard similarity coefficient)的方法來計算,找出關鍵文件。傑<br>卡德相似係數的公式如下,在兩個集合 A 與 B 中,兩個集合A和B的交集元素個數在A,B的聯集元素個<br>數中所佔的比例,就是它們的傑卡德相似係數:<br>J ( A , B  ) = | A ∩ B |/ | A ∪ B |<br>因此如果對下面兩個文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d 1 = “this is a book”</span><br><span class="line">d 2 = “this is a pen”</span><br><span class="line">J(d 1, d 2 )=3/5=0.6</span><br></pre></td></tr></table></figure></p><p>C教授同時要用multithreaded programming 的方式來設計程式。每一份文件對其他M-1份文件的平均傑卡<br>德相似係數(Average J(d 1, d 2 ))是由一個單獨的thread 來計算出來。所有文件會放在一個檔案中,程式須由<br>命令列讀入檔名。檔案中最多會有50個文件。每個文件會有兩行資料,第一行是文件的ID,第二行是文<br>件內容。文件ID會是一個字串,文件內容中的字詞會由一個或多個空白隔開。傑卡德相似係數如果有多<br>位小數,需要至少精準到小數點後5位。在處理文件時,依照下面規則處理:</p><ol><li>只考慮純字母組成的詞。</li><li>如果有重複出現的詞,只計算一次。例如: “a good book is a book” 中, “book”只算出現一次。<br>在程式執行時,</li><li>主執行緒針對文件數量產生對應的子執行緒。例如有4份文件,就產生4個子執行緒。主執行緒並負<br>責印出來下列事項,印出內容時,每一行需要印出 “[Main thread]”:<br>a. 每一個子執行緒的 tid,以及所負責計算的主文件ID。<br>b. 具有最高平均傑卡德相似係數的文件ID及文件內容。<br>c. 整個程式會用多少CPU時間 (以ms為單位)。</li><li>子執行緒則負責計算傑卡德相似係數。執行過程中,要列印出本身的動作,並且每一行都要印出自<br>己的thread id 。以下是需要印出的項目:<br>a. 負責計算的主文件ID編號。<br>b. 子執行緒計算傑卡德相似係數時,要印出是哪兩個文件在計算,以及它們Jaccard similarity。<br>c. 最後的平均傑卡德相似係數。<br>d. 子執行緒執行會用多少CPU時間 (以ms為單位)。<br>以下是一個可能的執行過程:<blockquote><p>prog2 data.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Main thread]: create TID:123, DocID:0001</span><br><span class="line">[TID=123] DocID:0001</span><br><span class="line">[TID=123] J(0001,0002)=0.6</span><br><span class="line">[TID=123] J(0001,0003)=0.6</span><br><span class="line">...</span><br><span class="line">[TID=123] AvgJ:0.511</span><br><span class="line">[TID=123] CPU time: 20ms</span><br><span class="line">...</span><br><span class="line">[Main thread] KeyDocID:0003 HighestJ:0.9999</span><br><span class="line">[Main thread] CPU time: 2000ms</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="二、-作業要點"><a href="#二、-作業要點" class="headerlink" title="二、 作業要點"></a>二、 作業要點</h2><ol><li>請注意,本作業使用的程式語言是C/C++,測試平台的作業系統: Ubuntu 17.10 LTS 64-bit。使用的<br>編譯程式為gcc/g++ 編譯器:7.2。其他平台或程式語言不在本次作業考慮範圍之內。如在測試平台上<br>無法編譯與執行,都不予給分。</li><li>請注意,本作業一定要用Pthread API來進行。任何不用Pthread API的程式,都不予給分。</li><li>本作業的評分方式如下:<br>a. 每一個項目能正確執行時,最多可得的分數如下<br>i. 從命令列讀入檔名參數,20分。<br>ii. 能產生 pthread,10分。<br>iii. 子執行緒可以印出本身的tid,20分。<br>iv. 傑卡德相似係數計算。不可以使用任何套件或函式庫,需自己完成。20分。<br>v.<br>印出執行所用的CPU時間,20分。<br>vi. 主執行緒找出關鍵文件並印出它的平均傑卡德相似係數,20分。</li><li>本作業需繳交檔案:<br>a. 說明報告:檔案為docx或pdf格式。<br>i. 報告中必須說明程式的設計理念、程式如何編譯,以及如何操作。<br>ii. 報告中同時必須詳細說明你完成哪些部份。如有用到特殊程式庫,請務必說明。<br>iii. 請務必讓助教明白如何編譯及測試你的程式。助教如果無法編譯或測試,會寄信(最多兩<br>次)通知你來說明,但每說明一次,助教會少給你10分。<br>b. 完整原始程式碼檔案。程式碼檔案必須是可直接編譯的檔案。不可含執行檔。助教會重新編譯你<br>們的程式。</li><li>所有相關檔案,例如報告檔、程式檔、參考資料等,請壓縮成一個壓縮檔(不可超過2MB)後上傳<br>至portal。請注意,不可抄襲。助教不會區分何者為原始版本,被判定抄襲者,一律0分。</li><li>如果傑卡德相似係數計算有使用網路範例,務必在作業中說明。該部份將不會計分,但不會判定為<br>抄襲。</li></ol><h2 id="三、-繳交方式"><a href="#三、-繳交方式" class="headerlink" title="三、 繳交方式:"></a>三、 繳交方式:</h2><ol><li>最終繳交時間:<br>a. 電子檔在 2018.05.11 以前,上傳至個人portal。如有多個檔案,將所有檔案壓縮成zip(rar 亦可)格<br>式,然後上傳。<br>b. 上傳檔名格式:「學號<em>作業號碼.docx」或「學號</em>作業號碼.rar」。例如:912233_01.doc 或<br>912233_01.rar。</li><li>如有違規事項者,依照課程規定處理。</li><li>如需請假,請上portal請假,並持相關證明文件,在請假結束後的第一次上課時完成請假手續,並在<br>一週內完成補交。補交作業將以8折計算。</li><li>老師不接受「門縫」方式繳交,助教也不接受任何作業。<h2 id="四、-如有未盡事宜-將在學校portal板面公告通知。"><a href="#四、-如有未盡事宜-將在學校portal板面公告通知。" class="headerlink" title="四、 如有未盡事宜,將在學校portal板面公告通知。"></a>四、 如有未盡事宜,將在學校portal板面公告通知。</h2><h2 id="五、-If-you-need-any-assistance-in-English-please-contact-Prof-Yang"><a href="#五、-If-you-need-any-assistance-in-English-please-contact-Prof-Yang" class="headerlink" title="五、 If you need any assistance in English, please contact Prof. Yang."></a>五、 If you need any assistance in English, please contact Prof. Yang.</h2><h2 id="六、-參考資料"><a href="#六、-參考資料" class="headerlink" title="六、 參考資料"></a>六、 參考資料</h2></li><li>參考課本圖 4.9。</li><li>PThread: <a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">https://computing.llnl.gov/tutorials/pthreads/</a></li><li>POSIX 線 程 (pthread) 入 門 文 章 分 享 : <a href="http://dragonspring.pixnet.net/blog/post/32963482-" target="_blank" rel="noopener">http://dragonspring.pixnet.net/blog/post/32963482-</a><br>posix%E7%B7%9A%E7%A8%8B%28pthread%29%E5%85%A5%E9%96%80%E6%96%87%E7%AB%A<br>0%E5%88%86%E4%BA%AB</li><li>Jaccard index wiki: <a href="https://en.wikipedia.org/wiki/Jaccard_index" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Jaccard_index</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c/c++代写:多线程编程&lt;br&gt;完成一个多线程变成,c/c++代写&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="多线程编程" scheme="http://holydudecs.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Multithreading" scheme="http://holydudecs.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>c++作业算法实现</title>
    <link href="http://holydudecs.github.io/2018/09/29/Task000001/"/>
    <id>http://holydudecs.github.io/2018/09/29/Task000001/</id>
    <published>2018-09-29T03:05:27.000Z</published>
    <updated>2018-10-09T12:48:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>cs代写 c++代写<br><a id="more"></a></p><h1 id="CMPSC-360-Discrete-Mathematics-for-Computer-Science"><a href="#CMPSC-360-Discrete-Mathematics-for-Computer-Science" class="headerlink" title="CMPSC 360: Discrete Mathematics for Computer Science"></a>CMPSC 360: Discrete Mathematics for Computer Science</h1><h2 id="Spring-2018-Project-April-3-2018"><a href="#Spring-2018-Project-April-3-2018" class="headerlink" title="Spring 2018 Project April 3, 2018"></a>Spring 2018 Project April 3, 2018</h2><h2 id="Project-Overview"><a href="#Project-Overview" class="headerlink" title="Project Overview"></a>Project Overview</h2><p>You have to implement what you have learned in CMPSC 360 to solve a practical problem of<br>your choice. The goal of the project is to help you in understanding the importance of the<br>concepts you are learning inside the classroom. Since the homework, recitations and other<br>quizzes are limited in scope this project will help you in understanding the practicality of discrete<br>mathematics with an interesting open-ended problem. You will also gain a very important skill of<br>carrying out research and communicating your findings in writing. Plus, it would really look cool<br>on your resume.</p><h2 id="Important-Dates"><a href="#Important-Dates" class="headerlink" title="Important Dates"></a>Important Dates</h2><p>The due date for submitting a proposal 7th April 2018 11:00 pm<br>The due date for submitting final project report and code: 24th April 2018 11:00 pm</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>The main requirement for this project is to demonstrate the ability to demonstrate that you<br>understand the CMPSC 30 concepts and their practical importance.<br>You can work in teams of maximum two students but remember that more the number of people<br>in team more the work should be in the project. We recommend working by yourself.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cs代写 c++代写&lt;br&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="http://holydudecs.github.io/tags/c-c/"/>
    
      <category term="Algorithm" scheme="http://holydudecs.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="http://holydudecs.github.io/tags/Datastructure/"/>
    
      <category term="算法" scheme="http://holydudecs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://holydudecs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
